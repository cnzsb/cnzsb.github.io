<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[奔跑的Q丶]]></title>
  <subtitle><![CDATA[奔跑的Q丶]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://zhaoshibo.net/"/>
  <updated>2017-03-09T16:11:43.000Z</updated>
  <id>http://zhaoshibo.net/</id>
  
  <author>
    <name><![CDATA[赵世博]]></name>
    <email><![CDATA[cnzsb@foxmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[从一个 CRUD 上手 React 和 AntD]]></title>
    <link href="http://zhaoshibo.net/blog/2017/03/09/%E4%BB%8E%E4%B8%80%E4%B8%AA%20CRUD%20%E4%B8%8A%E6%89%8B%20React%20%E5%92%8C%20AntD/"/>
    <id>http://zhaoshibo.net/blog/2017/03/09/从一个 CRUD 上手 React 和 AntD/</id>
    <published>2017-03-09T15:36:05.000Z</published>
    <updated>2017-03-09T16:11:43.000Z</updated>
    <content type="html"><![CDATA[<p>换了新公司后，技术栈使用的是 react。虽然一路从 vue 1 到 vue 2，但是我还是对 react 有好感的，当初学习 vue 1 文档少的可怜的时候也是借鉴了不少 react 的文章才得以理解，因此在接下来的文章中会小部分的对比下 react 和 vue 的不同。本次的文章主要是关于初次接触 react，并开发出一个具有 CRUD 功能页面的过程。提前了解本项目的详情请点击 <a href="https://github.com/cnzsb/react-antd-crud" target="_blank" rel="external">GitHub 地址</a>和<a href="http://www.zhaoshibo.net/react-antd-crud/" target="_blank" rel="external">线上预览地址</a>。</p>
<a id="more"></a>
<h2 id="需求背景">需求背景</h2><p>本项目其实是一个入职的 training project，项目需求就是做一个 CRUD 的管理页面。要求基础框架仅使用 react （不含 redux 之类的）和 antd，AJAX 库使用的是公司基于 axios 封装的库。项目提供了数据库和一个不完整的接口（好吧，其实只有其中一张表的 get），鉴于此这个项目使用了前端的方法仅做展示使用。</p>
<h2 id="学习_React">学习 React</h2><p>先把项目需求放一边，对于没接触过 react 自然应该先把基本的语法学习一下。我是先看了官方的 <a href="https://facebook.github.io/react/tutorial/tutorial.html" target="_blank" rel="external">tutorial</a> 之后去看<a href="https://facebook.github.io/react/docs/installation.html" target="_blank" rel="external">文档</a>，因为时间比较紧，所以只计划了 2 天的时间，这点时间我只看到了 “Optimizing Performance” 这一章。</p>
<h3 id="与_Vue_的异同">与 Vue 的异同</h3><p>因为接触过 vue，所以在读文档时自然而然就会在心中做一个对比。</p>
<h4 id="1-_语法区别">1. 语法区别</h4><p>虽然 vue 2 已经支持 JSX 的写法了，但是多数情况下都是用模板语法进行开发的。而 react 的 “all in js” 的理念一上来会让代码读起来有点痛苦，不过适应了之后其实和模板语法也没什么区别，简单理解在 vue 中习惯把 <code>template</code> 放在最上面，而 react 的 <code>render</code> 是在最下面的。另外在 react 中的作用域 <code>this</code> 需要特别注意。</p>
<p>vue 提供了 <code>v-for</code>、<code>v-if</code> 等的语法方便渲染 DOM。而在 react 中推荐抽离组件的思维，也就是一个可以复用的 <code>li</code> 完全可以自成一个组件，随后我们可以利用 JS 的 <code>map</code>、<code>if</code> 等方法直接进行操作。</p>
<h4 id="2-_单项数据流和双向绑定">2. 单项数据流和双向绑定</h4><p>react 推崇单向数据流，而 vue 是双向绑定的。vue 从 1 升级到 2 之后也开始推荐单向传递、父子组件独立的思维，如移除了 <code>props</code> 的 <code>twoway</code>等。</p>
<p>这里不得不提的就是 <code>props</code>，vue 2 版本中为了排除父子组件的耦合，移除了旧的 <code>$dispatch</code> 和 <code>$broadcast</code>，假设不使用 eventbus 和 vuex 的情况下，我的开发思路一般都是子组件仅用来接受上层处理好的数据而不独立处理数据，因此方法一般都存在于父组件之中。</p>
<p>而 react 在不使用其他状态管理的情况下，一般需要通过父组件提供的方法来操作从父组件传进子组件的数据。假设存在父组件 A 和 子组件 B，处理方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件 B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">label</span>&gt;</span></span><br><span class="line">                子组件的输入框：</span><br><span class="line">                    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">value</span>=<span class="value">&#123;this.props.value&#125;</span> <span class="attribute">onChange</span>=<span class="value">&#123;this.props.onChange&#125;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">        )</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件 A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">      <span class="keyword">super</span>()       <span class="comment">// 一般情况下传递参数 props 其实没有用，而如果在 constructor 中则使用了 this.props 则必须写入参数</span></span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        value: <span class="string">''</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">this</span>.onChange = <span class="keyword">this</span>.onChange.bind(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    onChange(event) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            value: event.target.value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">B</span> <span class="attribute">value</span>=<span class="value">&#123;this.state.value&#125;</span> <span class="attribute">onChange</span>=<span class="value">&#123;this.onChange&#125;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">p</span>&gt;</span>父组件的内容：&#123;this.state.value&#125;<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">        )</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在嵌套过深的父子组件中，这种单向的方式非常方便追踪数据问题等，而开发过程会相对麻烦一些。这在接下来的 CRUD 项目中把我绕的非常晕，而等到表单出问题的时候又让我立马体会到了其中的便利。</p>
<h4 id="3-_生命周期">3. 生命周期</h4><p>react 的生命周期提供了更多的钩子，方便我们决定在哪里进行操作和定位等。这里通过一张不知来源的图作为参考。</p>
<p><img src="http://7xlivs.com1.z0.glb.clouddn.com/2017/03/09/%E4%BB%8E%E4%B8%80%E4%B8%AA%20CRUD%20%E4%B8%8A%E6%89%8B%20React%20%E5%92%8C%20AntD/React%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="React 生命周期"></p>
<h2 id="准备开发">准备开发</h2><p>通过与已知知识的对比来学习新技术会帮助更好的上手，时间问题了解了大概核心的问题后基本上就可以开始项目了。在开始项目之前还需要大概了解下要使用的 UI 库，了解一下开发中可能用到的部分即可：布局、表单、表格、分页、按钮和通知等。</p>
<h3 id="1-_搭建环境">1. 搭建环境</h3><p>本文的环境以 <a href="https://github.com/cnzsb/react-antd-crud" target="_blank" rel="external">github</a> 上的仓库来介绍。实际开发时使用的是公司脚手架生成的包含 java 的环境，并在 tomacat 的服务器上进行的开发。</p>
<p>本次项目的重点是实践 react，因此环境部分的配置不过多介绍。我利用了官方脚手架 <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">creat-react-app</a> 生成文件目录。之后修改了生成目录为 docs，为了配合 github-pages 来显示；修改了 webpack 中 babel-loader 的配置来实现 antd 组件的按需加载。</p>
<h3 id="2-_开发思路">2. 开发思路</h3><p>开发之前需要理清楚页面的层次结构和组件结构。 这里先把最后的项目目录放下来，然后来讲设计思路。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">|-- api</span><br><span class="line">|   |-- sqlData.js      <span class="comment"># 操作 sqlData 的 ajax 方法</span></span><br><span class="line">|-- components</span><br><span class="line">|   |-- App.jsx         <span class="comment"># 页面</span></span><br><span class="line">|   |-- Content.jsx     <span class="comment"># 页面主体内容区</span></span><br><span class="line">|   |-- Factory.jsx     <span class="comment"># 表单组件工厂</span></span><br><span class="line">|   |-- FormModal.jsx   <span class="comment"># 弹出的增加或编辑的表单组件</span></span><br><span class="line">|   |-- Search.jsx      <span class="comment"># 搜索组件</span></span><br><span class="line">|-- libs</span><br><span class="line">|   |-- ajax.js         <span class="comment"># ajax 实例及公共方法</span></span><br><span class="line">|   |-- util.js         <span class="comment"># 工具方法</span></span><br><span class="line">|-- store</span><br><span class="line">|   |-- sqlConfig.js    <span class="comment"># 数据库表单配置项</span></span><br><span class="line">|-- index.js            <span class="comment"># 入口文件</span></span><br><span class="line">|-- style.css           <span class="comment"># 样式文件</span></span><br></pre></td></tr></table></figure>
<p>首先项目需求中本来是存在多张表的，虽然因为种种原因仅只提供了一张表的获取接口，但是为了能够在有第 n 张表来的时候可以随意配置，因此我单独抽离了数据库配置文件，为了就是以后再有新需求可以“偷懒”少写代码。</p>
<p>在 <code>sqlConfig.js</code> 中我定义了每一个需要展示的 table header 的 <code>type</code>，从而按需渲染不同的表单类型，如 <code>input</code> 的 <code>text</code> 类型，或者仅做展示的 <code>display</code> 类型，以后还可以扩展 <code>date</code> 类型等。另外根据 antd 中的配置需要，增加了对应的比较重要的配置项，如 <code>width</code>。另外我也定义了 <code>validators</code> 来对每一项进行校验，实际项目中因为时间问题并没有完善此功能。</p>
<p>在有了思路后，就要去布局组件的位置，从而决定哪里最适合负责总的 state 管理，哪里又适合 props。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-- App</span><br><span class="line">|   |-- Menu                <span class="comment"># 导航菜单</span></span><br><span class="line">|   |-- Content             <span class="comment"># 主要内容区</span></span><br><span class="line">|       |-- Search          <span class="comment"># 搜索组件</span></span><br><span class="line">|           |-- Factory     <span class="comment"># 表单工厂</span></span><br><span class="line">|       |-- ButtonGroup     <span class="comment"># 操作按钮群</span></span><br><span class="line">|       |-- Table           <span class="comment"># 表格组件</span></span><br><span class="line">|           |-- Pagination  <span class="comment"># 分页组件</span></span><br><span class="line">|       |-- FormModal       <span class="comment"># 弹出的编辑表单</span></span><br><span class="line">|           |-- Factory     <span class="comment"># 表单工厂</span></span><br></pre></td></tr></table></figure>
<p>在最终的 react 组件中，按照重要程度，结构大致如上。我们通过下图来了解组件间具体如何通信。</p>
<p><img src="http://7xlivs.com1.z0.glb.clouddn.com/2017/03/09/%E4%BB%8E%E4%B8%80%E4%B8%AA%20CRUD%20%E4%B8%8A%E6%89%8B%20React%20%E5%92%8C%20AntD/react-antd-crud.png" alt="react-antd-crud"></p>
<p>基本的结构有了之后，接下来就是 ajax 具体如何使用了，这里我们使用了 axios，并对 ajax 进行一个全局的默认设置，把所有的错误都进行了同样的提示，这些设置保存在 <code>libs/ajax.js</code> 文件中。</p>
<h2 id="开发总结">开发总结</h2><p>整个开发过程使用了三天时间。最难的第一个地方就是在接受 <code>props</code> 之后选择哪一个生命周期的钩子函数进行 <code>setState</code> 更新；第二个地方是组件之间各种状态传递的时候实在把我绕晕了，主要还是没有适应 react 的模式；第三个地方是在使用 antd 的 <code>table</code> 组件的 <code>rowSelection</code> 时，为了每一次都能让 <code>selectedRowKeys</code> 与组件对应 <code>state</code> 中的该值同步，需要把 <code>rowSelection</code> 的赋值操作放在 <code>render</code> 中，从而触发每一次组件更新的 <code>render</code> 方法。</p>
<p>除了缺点之外，本项目做到了抽离及复用组件，项目中的 <code>Factory</code> 组件可以根据配置文件生成对应类型的表单元素，进一步开发的话可以把 <code>validators</code> 的功能增加进去。对于编辑和新增表单这些验证规则可能和搜索组件 <code>Search</code> 中的不太一样，如果有要求的话，可以再定制维护一份对应搜索组件的 <code>Factory</code> 也是可以的。综上而言本项目在之后引入新的数据库表和对应的接口的话，配置相关的 <code>sqlConfig</code> 文件即能轻松实现复用。另外项目中简单的配置了 axios 的响应数据类型后的规则，做到了总的处理，具体的相关配置还需要参考<a href="https://github.com/mzabriskie/axios" target="_blank" rel="external">官方文档</a>。</p>
<p>综上，本篇文章侧重记录了项目的主要流程及思考方式，并没有详细解释 react 或者 antd 的相关知识，权当抛砖引玉，深入的内容还需要不断学习才能掌握，多看文档多实践。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>换了新公司后，技术栈使用的是 react。虽然一路从 vue 1 到 vue 2，但是我还是对 react 有好感的，当初学习 vue 1 文档少的可怜的时候也是借鉴了不少 react 的文章才得以理解，因此在接下来的文章中会小部分的对比下 react 和 vue 的不同。本次的文章主要是关于初次接触 react，并开发出一个具有 CRUD 功能页面的过程。提前了解本项目的详情请点击 <a href="https://github.com/cnzsb/react-antd-crud">GitHub 地址</a>和<a href="http://www.zhaoshibo.net/react-antd-crud/">线上预览地址</a>。</p>]]>
    
    </summary>
    
      <category term="AntD" scheme="http://zhaoshibo.net/tags/AntD/"/>
    
      <category term="React" scheme="http://zhaoshibo.net/tags/React/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[添加多个 SSH 秘钥]]></title>
    <link href="http://zhaoshibo.net/blog/2017/02/28/%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%20SSH%20%E7%A7%98%E9%92%A5/"/>
    <id>http://zhaoshibo.net/blog/2017/02/28/添加多个 SSH 秘钥/</id>
    <published>2017-02-28T15:40:30.000Z</published>
    <updated>2017-03-06T10:04:39.000Z</updated>
    <content type="html"><![CDATA[<p>本月堆积了好几篇文章没写了，趁着最后几十分钟，为了完成年初计划马虎更新一篇记录性的文章吧。由于本月刚换了新的公司，新公司的代码托管在 GitLab 上，因此有了管理 2 个 SSH 秘钥的需求，查阅资料后发现并不难，记录与分享一下。</p>
<p>首先生成 SSH 的指令不陌生：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"邮箱地址"</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/your_user_directory/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>
<p>默认会存放在个人文档根目录下的 <code>.ssh</code> 下，并以 <code>id_rsa</code> 的文件名生成秘钥对。<a id="more"></a>方便起见我没有修改已经存在的这两个配置文件。接下来的操作自然是再生成一份配置文件，但是注意选择保存的时候要改为其他名字防止覆盖已有文件，比如以 <code>id_rsa_other</code> 新命名。</p>
<p>接下来需要利用 <code>ssh-add</code> 相关命令添加对应的标识。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa_other</span><br><span class="line">ssh-add -L  <span class="comment"># 查看已生成的列表，用来确认是否添加成功</span></span><br></pre></td></tr></table></figure>
<p>最后还需要在 <code>.ssh</code> 文件夹下创建一份 <code>config</code> 配置文件，文件内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># github.com</span></span><br><span class="line">Host github.com</span><br><span class="line">        HostName github.com</span><br><span class="line">        User git</span><br><span class="line">        IdentityFile ~/.ssh/id_rsa</span><br><span class="line"><span class="comment"># gitlab.other.com</span></span><br><span class="line">Host gitlab.other.com</span><br><span class="line">        HostName gitlab.other.com</span><br><span class="line">        User git</span><br><span class="line">        IdentityFile ~/.ssh/id_rsa_other</span><br></pre></td></tr></table></figure>
<p>最最后，如果需要测试的话可以执行 <code>ssh -T &quot;git@HOST&quot;</code> 进行检验。但是一般公司内的服务器是不会给个人开通权限也就没办法利用这个指令测试了，不过可以尝试 <code>clone</code> 一个仓库来检测是否成功。</p>
<p>具体在开发时还需要记得在相应的仓库中重新配置 <code>git config</code> 对应的用户名及邮箱哦。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本月堆积了好几篇文章没写了，趁着最后几十分钟，为了完成年初计划马虎更新一篇记录性的文章吧。由于本月刚换了新的公司，新公司的代码托管在 GitLab 上，因此有了管理 2 个 SSH 秘钥的需求，查阅资料后发现并不难，记录与分享一下。</p>
<p>首先生成 SSH 的指令不陌生：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"邮箱地址"</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/your_user_directory/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>
<p>默认会存放在个人文档根目录下的 <code>.ssh</code> 下，并以 <code>id_rsa</code> 的文件名生成秘钥对。]]>
    
    </summary>
    
      <category term="Git" scheme="http://zhaoshibo.net/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Plus —— JS 面试题]]></title>
    <link href="http://zhaoshibo.net/blog/2017/02/06/Plus%20%E2%80%94%E2%80%94%20JS%20%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://zhaoshibo.net/blog/2017/02/06/Plus —— JS 面试题/</id>
    <published>2017-02-06T08:16:59.000Z</published>
    <updated>2017-02-06T08:56:27.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>设计一个 plus 方法，达到以下测试结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">'use strict'</span></span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>)</span><br><span class="line">describe(<span class="string">'闭包应用'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  it(<span class="string">'plus(0) === 0'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    assert.equal(<span class="number">0</span>, plus(<span class="number">0</span>).toString())</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">'plus(1)(1)(2)(3)(5) === 12'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    assert.equal(<span class="number">12</span>, plus(<span class="number">1</span>)(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">5</span>).toString())</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">'plus(1)(4)(2)(3) === 10'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    assert.equal(<span class="number">10</span>,plus(<span class="number">1</span>)(<span class="number">4</span>)(<span class="number">2</span>)(<span class="number">3</span>).toString())</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">'方法引用'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> plus2 = plus(<span class="number">1</span>)(<span class="number">1</span>)</span><br><span class="line">    assert.equal(<span class="number">12</span>, plus2(<span class="number">1</span>)(<span class="number">4</span>)(<span class="number">2</span>)(<span class="number">3</span>).toString())</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<a id="more"></a>
<p>看到本题，首先就会发现正常的函数操作只是暂时存储了所有参数，而 toString 方法才是用来真正的执行方法，因此在默认的行为中只需要利用闭包来存储数据即可，并不难理解。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plusA</span>(<span class="params">...num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = []</span><br><span class="line">  args.push(...num)</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">...n</span>) </span>&#123;</span><br><span class="line">    args.push(...n)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  sum.toString = () =&gt; args.reduce((a, b) =&gt; a + b)</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'方法一测试结果：'</span>)</span><br><span class="line">test(plusA)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 2，内部通过柯里化来实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plusB</span>(<span class="params">...num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = []</span><br><span class="line">    <span class="keyword">var</span> save = <span class="function"><span class="keyword">function</span> (<span class="params">...n</span>) </span>&#123;</span><br><span class="line">      args.push(...n)</span><br><span class="line">      <span class="keyword">return</span> save</span><br><span class="line">    &#125;</span><br><span class="line">    save.toString = () =&gt; args.reduce((a, b) =&gt; a + b)</span><br><span class="line">    <span class="keyword">return</span> save</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum()(...num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'方法二测试结果：'</span>)</span><br><span class="line">test(plusB)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">plus</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(plus(<span class="number">0</span>, <span class="number">1</span>).toString())</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">12</span> === plus(<span class="number">1</span>)(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">5</span>).toString())</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">10</span> === plus(<span class="number">1</span>)(<span class="number">4</span>)(<span class="number">2</span>)(<span class="number">3</span>).toString())</span><br><span class="line">  <span class="keyword">var</span> plus2 = plus(<span class="number">1</span>)(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">12</span> === plus2(<span class="number">1</span>)(<span class="number">4</span>)(<span class="number">2</span>)(<span class="number">3</span>).toString())</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'多参数执行, plus(1, 2)(3, 4): '</span>, plus(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>).toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>设计一个 plus 方法，达到以下测试结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">'use strict'</span></span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>)</span><br><span class="line">describe(<span class="string">'闭包应用'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  it(<span class="string">'plus(0) === 0'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    assert.equal(<span class="number">0</span>, plus(<span class="number">0</span>).toString())</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">'plus(1)(1)(2)(3)(5) === 12'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    assert.equal(<span class="number">12</span>, plus(<span class="number">1</span>)(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">5</span>).toString())</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">'plus(1)(4)(2)(3) === 10'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    assert.equal(<span class="number">10</span>,plus(<span class="number">1</span>)(<span class="number">4</span>)(<span class="number">2</span>)(<span class="number">3</span>).toString())</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">'方法引用'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> plus2 = plus(<span class="number">1</span>)(<span class="number">1</span>)</span><br><span class="line">    assert.equal(<span class="number">12</span>, plus2(<span class="number">1</span>)(<span class="number">4</span>)(<span class="number">2</span>)(<span class="number">3</span>).toString())</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://zhaoshibo.net/tags/JavaScript/"/>
    
      <category term="面试题" scheme="http://zhaoshibo.net/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LazyMan —— JS 面试题]]></title>
    <link href="http://zhaoshibo.net/blog/2017/01/24/LazyMan%20%E2%80%94%E2%80%94%20JS%20%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://zhaoshibo.net/blog/2017/01/24/LazyMan —— JS 面试题/</id>
    <published>2017-01-24T09:27:43.000Z</published>
    <updated>2017-02-06T08:12:12.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>实现一个LazyMan，可以按照以下方式调用：</p>
<p>LazyMan(“Hank”)</p>
<p>输出：Hi! This is Hank!</p>
<p>LazyMan(“Hank”).sleep(10).eat(“dinner”)</p>
<p>输出: Hi! This is Hank!</p>
<a id="more"></a>
<p>等待10秒..</p>
<p>Wake up after 10</p>
<p>Eat dinner~</p>
<p>LazyMan(“Hank”).eat(“dinner”).eat(“supper”)</p>
<p>输出：Hi This is Hank!</p>
<p>Eat dinner~</p>
<p>Eat supper~</p>
<p>LazyMan(“Hank”).sleepFirst(5).eat(“supper”)</p>
<p>输出：等待5秒</p>
<p>Wake up after 5</p>
<p>Hi This is Hank!</p>
<p>Eat supper</p>
<p>以此类推。</p>
</blockquote>
<p>本题考察了典型的先进先出的队列结构，因此可以使用一个数组 queue 来存取要操作的方法，然后利用 js 的定时器来处理事件循环，并且在每次触发事件后返回自身达到链式调用，在构造函数中需要注意的是作用域的变更，在适当的地方使用 self 或者闭包来解决这个问题。<a href="http://codepen.io/cnzsb/pen/RKpKgZ/" target="_blank" rel="external">具体的答案如下所示</a>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_LazyMan</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.queue = []</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span> (<span class="params">that</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Hi! This is <span class="subst">$&#123;name&#125;</span>!`</span>)</span><br><span class="line">      that.next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">this</span>.queue.push(fn)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 下一个事件循环执行</span></span><br><span class="line">  setTimeout(<span class="keyword">this</span>.next.bind(<span class="keyword">this</span>), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现事件循环,在某个事件完成时重新调用 next 方法</span></span><br><span class="line">_LazyMan.prototype.next = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="keyword">this</span>.queue.shift()</span><br><span class="line">  fn &amp;&amp; fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_LazyMan.prototype.sleep = <span class="function"><span class="keyword">function</span> (<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span> (<span class="params">that</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Wake up after <span class="subst">$&#123;time&#125;</span>`</span>)</span><br><span class="line">        that.next()</span><br><span class="line">      &#125;, time * <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">this</span>.queue.push(fn)</span><br><span class="line">  <span class="comment">// 链式调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_LazyMan.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span> (<span class="params">that</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Eat <span class="subst">$&#123;food&#125;</span>~`</span>)</span><br><span class="line">      that.next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">this</span>.queue.push(fn)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_LazyMan.prototype.sleepFirst = <span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span> (<span class="params">that</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Wake up after <span class="subst">$&#123;time&#125;</span>`</span>)</span><br><span class="line">      that.next()</span><br><span class="line">    &#125;, time * <span class="number">1000</span>)</span><br><span class="line">  &#125;)(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">this</span>.queue.unshift(fn)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> LazyMan = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> _LazyMan(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LazyMan(<span class="string">'Hank1'</span>).sleep(<span class="number">10</span>).eat(<span class="string">'dinner'</span>)</span><br><span class="line"><span class="comment">// LazyMan('Hank2').eat('dinner').eat('supper')</span></span><br><span class="line"><span class="comment">// LazyMan('Hank3').sleepFirst(5).eat('supper')</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>实现一个LazyMan，可以按照以下方式调用：</p>
<p>LazyMan(“Hank”)</p>
<p>输出：Hi! This is Hank!</p>
<p>LazyMan(“Hank”).sleep(10).eat(“dinner”)</p>
<p>输出: Hi! This is Hank!</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://zhaoshibo.net/tags/JavaScript/"/>
    
      <category term="面试题" scheme="http://zhaoshibo.net/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[多栏布局]]></title>
    <link href="http://zhaoshibo.net/blog/2017/01/18/%E5%A4%9A%E6%A0%8F%E5%B8%83%E5%B1%80/"/>
    <id>http://zhaoshibo.net/blog/2017/01/18/多栏布局/</id>
    <published>2017-01-18T12:57:42.000Z</published>
    <updated>2017-01-18T13:00:01.000Z</updated>
    <content type="html"><![CDATA[<p>现在很少接触到太多的 CSS 问题了，多数情况下 flex 都是最佳的选择，慢慢也就对基础生疏了，今天来总结下常见的布局问题。示例中关于 flex 的布局都比较简单，不理解的需要重新补习 <a href="/blog/2016/05/04/flex布局/">flex</a> 基础。本文中的示例和代码都在 <a href="http://codepen.io" target="_blank" rel="external">codepen</a> 上，如果加载异常请先科学上网。</p>
<p>具有固定宽高的布局方式在实际需求中其实很少见，一般都会有自适应的区域，接下来就来看看常用的几种布局。</p>
<a id="more"></a>
<h2 id="两栏布局">两栏布局</h2><p>常见的两栏布局一般是左侧固定，右侧自适应。</p>
<ol>
<li><p>float</p>
<iframe height="162" scrolling="no" title="两栏布局 - float" src="http://codepen.io/cnzsb/embed/XpXxKj/?height=162&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/cnzsb/pen/XpXxKj/" target="_blank" rel="external">两栏布局 - float</a> by Shibo Zhao (<a href="http://codepen.io/cnzsb" target="_blank" rel="external">@cnzsb</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>
</li>
<li><p>position</p>
<iframe height="183" scrolling="no" title="两栏布局 - position" src="http://codepen.io/cnzsb/embed/xgZyXX/?height=183&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/cnzsb/pen/xgZyXX/" target="_blank" rel="external">两栏布局 - position</a> by Shibo Zhao (<a href="http://codepen.io/cnzsb" target="_blank" rel="external">@cnzsb</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>
</li>
<li><p>table-cell</p>
<iframe height="179" scrolling="no" title="两栏布局 - table-cell" src="http://codepen.io/cnzsb/embed/OWXJaM/?height=179&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/cnzsb/pen/OWXJaM/" target="_blank" rel="external">两栏布局 - table-cell</a> by Shibo Zhao (<a href="http://codepen.io/cnzsb" target="_blank" rel="external">@cnzsb</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>
</li>
<li><p>flex</p>
<iframe height="227" scrolling="no" title="两侧定宽，中间自适应 - flex" src="http://codepen.io/cnzsb/embed/dNMZWa/?height=227&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/cnzsb/pen/dNMZWa/" target="_blank" rel="external">两侧定宽，中间自适应 - flex</a> by Shibo Zhao (<a href="http://codepen.io/cnzsb" target="_blank" rel="external">@cnzsb</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

</li>
</ol>
<h2 id="三栏布局">三栏布局</h2><p>简单的三栏布局可以拆分成两栏布局嵌套两栏布局的方式设计，在此基础上如果拆分为中间元素和两侧元素的话，则需要真正的三栏布局来设计了。</p>
<p>首先是左右固定，中间自适应的布局。</p>
<ol>
<li><p>float</p>
<iframe height="201" scrolling="no" title="两侧定宽，中间自适应 - float" src="http://codepen.io/cnzsb/embed/GroYQz/?height=201&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/cnzsb/pen/GroYQz/" target="_blank" rel="external">两侧定宽，中间自适应 - float</a> by Shibo Zhao (<a href="http://codepen.io/cnzsb" target="_blank" rel="external">@cnzsb</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>
</li>
<li><p>float + margin 负值，两栏布局也可以采用这种方法</p>
<iframe height="257" scrolling="no" title="两侧定宽，中间自适应 - float + margin 负值" src="http://codepen.io/cnzsb/embed/ygeQMz/?height=257&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/cnzsb/pen/ygeQMz/" target="_blank" rel="external">两侧定宽，中间自适应 - float + margin 负值</a> by Shibo Zhao (<a href="http://codepen.io/cnzsb" target="_blank" rel="external">@cnzsb</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>
</li>
<li><p>position</p>
<iframe height="246" scrolling="no" title="两侧定宽，中间自适应 - position" src="http://codepen.io/cnzsb/embed/dNGgxw/?height=246&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/cnzsb/pen/dNGgxw/" target="_blank" rel="external">两侧定宽，中间自适应 - position</a> by Shibo Zhao (<a href="http://codepen.io/cnzsb" target="_blank" rel="external">@cnzsb</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>
</li>
<li><p>flex</p>
<iframe height="232" scrolling="no" title="两侧定宽，中间自适应 - flex" src="http://codepen.io/cnzsb/embed/dNMZWa/?height=232&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/cnzsb/pen/dNMZWa/" target="_blank" rel="external">两侧定宽，中间自适应 - flex</a> by Shibo Zhao (<a href="http://codepen.io/cnzsb" target="_blank" rel="external">@cnzsb</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

</li>
</ol>
<p>另一种是中间定宽，两侧自适应的布局。这个情况需要在固定中间元素的前提下，使左右两侧浮动或者绝对定位即可，下例使用 float 做了演示，同上述例子类似，float 的元素也可以使用 position 进行绝对定位替换，这里不再演示。</p>
<iframe height="268" scrolling="no" title="中间定宽，两侧自适应 - float + position" src="http://codepen.io/cnzsb/embed/oBLjGQ/?height=268&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/cnzsb/pen/oBLjGQ/" target="_blank" rel="external">中间定宽，两侧自适应 - float + position</a> by Shibo Zhao (<a href="http://codepen.io/cnzsb" target="_blank" rel="external">@cnzsb</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h2 id="等高布局">等高布局</h2><p>等高布局是一种要求各栏背景颜色填充至等高的样式。</p>
<ol>
<li><p>两栏等高</p>
<iframe height="189" scrolling="no" title="两栏等高布局" src="http://codepen.io/cnzsb/embed/BpQZNq/?height=189&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/cnzsb/pen/BpQZNq/" target="_blank" rel="external">两栏等高布局</a> by Shibo Zhao (<a href="http://codepen.io/cnzsb" target="_blank" rel="external">@cnzsb</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>
</li>
<li><p>三栏等高</p>
<iframe height="320" scrolling="no" title="三栏等高布局" src="http://codepen.io/cnzsb/embed/OWbjyJ/?height=320&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/cnzsb/pen/OWbjyJ/" target="_blank" rel="external">三栏等高布局</a> by Shibo Zhao (<a href="http://codepen.io/cnzsb" target="_blank" rel="external">@cnzsb</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

</li>
</ol>
<p>以上布局如果需要流式布局，宽度替换为百分比即可。关于三栏等高布局，根据上例下图能帮助很好的理解。其中主要利用了相对定位的方式，2 层容器的 right 距离为第三栏（最右栏）元素的宽度，3 层容器的 right 距离为第二栏（中间栏）的宽度；对于子栏目来讲，它们的 left 距离均为除了第一栏（最左栏）的宽度之和。理解了原理之后，根据需要，扩展更多的子栏也可以运用同样的方式。</p>
<p><img src="http://7xlivs.com1.z0.glb.clouddn.com/2017/01/18/%E5%A4%9A%E6%A0%8F%E5%B8%83%E5%B1%80/%E4%B8%89%E6%A0%8F%E7%AD%89%E9%AB%98%E5%B8%83%E5%B1%80%E5%9B%BE%E8%A7%A3.png" alt="三栏等高布局图解"></p>
<h2 id="小结">小结</h2><p>本文仅仅展示了几种常见的布局结构以及对应的常用方法，自适应的布局在页面重构中很经常遇到，需要加强更多的响应式知识才能熟练。</p>
<h2 id="参考资料">参考资料</h2><ol>
<li><a href="http://www.cnblogs.com/jununx/p/3336553.html" target="_blank" rel="external">两栏布局，三栏布局，等高布局，流式布局</a></li>
<li><a href="https://www.w3cplus.com/css/creaet-equal-height-columns" target="_blank" rel="external">八种创建等高列布局</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>现在很少接触到太多的 CSS 问题了，多数情况下 flex 都是最佳的选择，慢慢也就对基础生疏了，今天来总结下常见的布局问题。示例中关于 flex 的布局都比较简单，不理解的需要重新补习 <a href="/blog/2016/05/04/flex布局/">flex</a> 基础。本文中的示例和代码都在 <a href="http://codepen.io">codepen</a> 上，如果加载异常请先科学上网。</p>
<p>具有固定宽高的布局方式在实际需求中其实很少见，一般都会有自适应的区域，接下来就来看看常用的几种布局。</p>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://zhaoshibo.net/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016 年终总结]]></title>
    <link href="http://zhaoshibo.net/blog/2017/01/05/2016%20%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://zhaoshibo.net/blog/2017/01/05/2016 年终总结/</id>
    <published>2017-01-05T10:09:23.000Z</published>
    <updated>2017-01-05T13:27:50.000Z</updated>
    <content type="html"><![CDATA[<p>又到了新的一年，总结一下过去的 2016 。翻看年初所定的目标，虽说有些没有很好的完成，然而还是觉得能给这一年打 80 分。此时我刚刚踏入前端一年半，真正参加工程化的项目不足一年，但恰恰是今年让我系统的理解了前端，对工作也更加游刃有余。</p>
<a id="more"></a>
<h2 id="上半年">上半年</h2><p>本来这里已经洋洋洒洒几千字的总结了，然而总觉得我似乎写成了简历一样，太不像一篇合格的总结，于是我决定从头开始写。😂</p>
<p>2016 的上半年我依然呆在我的第一份前端工作的公司，做着最普通的切图仔的任务。不甘平庸的同时自学了很多进阶知识，然而没有大型项目，也没有很好的技术栈实践，最终导致只是有一大堆知识拥堵在我的脑中。没有成型的项目实践，因此带来了很多困惑，诸如为什么会有闭包导致的事件绑定失败，slice 、substr 和 substring 永远分不清，以及到底什么是 DOM 等等。所有这些东西都只能靠着自己的感觉来掌握，效率低下。最终为了更好的发展我还是选择了跳槽，好来快点结束这样的状态。</p>
<p>跳槽的过程中，最深刻的是在<em>野兽派</em>的面试，被邀请的当天我本来已经不再想继续面试了，只是看了他们的简介后想着就当聊天了（原谅我当时不知道他们是一家很知名的鲜花公司）。面试过程中基本上没有聊什么无聊的话题，直奔主题的提问了几道问题：</p>
<blockquote>
<ol>
<li>移动端的 viewport 中，initial-scale 为 1 的时候，16px 的文字会显示多大；如果一个 PC 16px 的文字想要在移动端显示为 32px ，应该如何设置这个值。</li>
<li>ES6 中的 super 的含义。</li>
<li>如果有一个表单，如何设计为可复用的组件。</li>
</ol>
</blockquote>
<p>可能还有几个小知识点我漏掉了，但是这些问题真的很经典，然而当时的我没有很好的掌握移动端的细节知识，ES6 还没有看过，面向对象等 JS 进阶知识一塌糊涂，只会方法式编程。这几道题的考查点都是能看出应聘者是否在平时对知识点有足够的思考，而不是拿来主义的直接使用网上的解决方案（如直接的复制 viewport 的 meta），二是对 JS 基础掌握的考察。之所以印象深刻，倒也不是这几道不同其他公司的面试题，而是过程中面试官对我频频引导，希望能看到我的成长潜力，我是真的有心无力，毕竟没有实践只会导致不成体系的知识。正是这一份宝贵的面试经验，在接下来就要到来的工作中给了我巨大的影响。</p>
<h2 id="下半年">下半年</h2><p>下班年在新的公司给我带来了巨大的提升，毕竟终于接触到系统化的工程了，我真的是天天都激动的不行。</p>
<p>一开始就是 Vue 配合 ES6 的项目，对于一个只会 jQuery 的我来说，读文档就吃力的不行，然而此时上文中所述的那一大坨积聚在我脑中的知识体随着新知识的注入开始慢慢的消化了，Dom 操作和面向数据的 MVVM ，事件和通信，Vue 实例对象以及原型等等，开始让这些知识体如游戏中的经验般让我频频有顿悟升级的感觉，那种舒爽简直觉得毒品也不过如此了🙃。随着项目的深入，我的知识体系也开始完善起来，至此我才终于觉得我入了前端的门了。</p>
<p>回顾后半年，先后经历了 Vue1 全家桶项目，微信项目，Weex App 项目，Vue2 全家桶项目等，这些项目经验配合书本等渠道获得的知识，前端的道路走的越来越宽。</p>
<h2 id="计划">计划</h2><p>用一个字形容 2016 ，就是<strong>升</strong>，技能、工作、生活等等全都有质的提升。随着技能的熟练掌握，工作和生活都开始趋于平静，慢慢也就想钻进舒适区不愿跳出了，是时候重新确立些目标了：</p>
<ul>
<li>2016 读的书都很有质量，然而却没有做好读书笔记，项目中碰到的知识点等也没有梳理成笔记，希望 2017 年能认真的记笔记，争取每周产出一篇，至少每月 2 篇</li>
<li>至少 12 本技术书籍</li>
<li>Github 完成至少一个完整的前端项目，希望后期能增加 Node 的后端工程</li>
</ul>
<p>2017 继续进步。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>又到了新的一年，总结一下过去的 2016 。翻看年初所定的目标，虽说有些没有很好的完成，然而还是觉得能给这一年打 80 分。此时我刚刚踏入前端一年半，真正参加工程化的项目不足一年，但恰恰是今年让我系统的理解了前端，对工作也更加游刃有余。</p>]]>
    
    </summary>
    
      <category term="生活" scheme="http://zhaoshibo.net/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解 JavaScipt new 操作符]]></title>
    <link href="http://zhaoshibo.net/blog/2016/10/19/%E7%90%86%E8%A7%A3%20JavaScipt%20new%20%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://zhaoshibo.net/blog/2016/10/19/理解 JavaScipt new 操作符/</id>
    <published>2016-10-19T10:10:53.000Z</published>
    <updated>2016-10-31T12:18:49.000Z</updated>
    <content type="html"><![CDATA[<p>在《JavaScript 高级程序设计》中提到使用 <code>new</code> 操作符会经历 4 个步骤：</p>
<blockquote>
<p>(1) 创建一个新对象；</p>
<p>(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</p>
<p>(3) 执行构造函数中的代码（为这个新对象添加属性）；</p>
<p>(4) 返回新对象。</p>
</blockquote>
<a id="more"></a>
<p>假设我们有一个构造函数 <code>Foo</code> 。这里要理解在创建了一个新函数时，就会根据一组特定的规则为该函数创建一个 <code>prototype</code> 属性，这个属性指向函数的原型对象。而在默认情况下，所有原型对象都会自动获得一个 <code>constructor</code> 属性，这个属性包含一个指向 <code>prototype</code> 属性所在函数的指针。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过 <code>new</code> 方法创建实例 <code>bar</code>。我们知道，当调用构造函数创建一个新实例后，该实例的内部将包含一个指针指向构造函数的原型对象。ECMA-262 第 5 版管这个指针叫 <code>[[Prototype]]</code> ，但Firefox、Chrome、Safari在每个对象上都支持一个属性 <code>__proto__</code> ，也就相当于这个属性。重要理解的是<strong>这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="string">'bar'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(bar)    <span class="comment">// Foo &#123;name: "bar"&#125;</span></span><br><span class="line">bar.getName()   <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<p>现在根据以上的规则，我们手动来实现一个 <code>new</code> 的过程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 首先创建一个空对象</span></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 把这个对象的 [[Prototype]] （__proto__）指向 Foo 的 prototype</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(baz, Foo.prototype)</span><br><span class="line"><span class="comment">// 在控制台中也可以这样写：</span></span><br><span class="line"><span class="comment">// baz.__proto__ = Foo.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 传递 FOO 的属性及作用域</span></span><br><span class="line">Foo.call(baz, <span class="string">'baz'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 验证</span></span><br><span class="line">baz.getName()   <span class="comment">// baz</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>在《JavaScript 高级程序设计》中提到使用 <code>new</code> 操作符会经历 4 个步骤：</p>
<blockquote>
<p>(1) 创建一个新对象；</p>
<p>(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</p>
<p>(3) 执行构造函数中的代码（为这个新对象添加属性）；</p>
<p>(4) 返回新对象。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://zhaoshibo.net/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery FormData 的 Ajax 提交]]></title>
    <link href="http://zhaoshibo.net/blog/2016/08/30/jQuery%20FormData%20%E7%9A%84%20Ajax%20%E6%8F%90%E4%BA%A4/"/>
    <id>http://zhaoshibo.net/blog/2016/08/30/jQuery FormData 的 Ajax 提交/</id>
    <published>2016-08-30T14:36:48.000Z</published>
    <updated>2016-10-31T12:18:49.000Z</updated>
    <content type="html"><![CDATA[<p>前些天恰好遇到用 jQuery 提交一个上传的文件一直出错，这里记录一下原因。</p>
<p>我们的项目本身是使用了 vue 的，但是历史原因同时也保留了 jQuery ，然后项目中用 Promise 重新封装了 jQuery 的 Ajax 方法。之前有一个共用的 upload 的上传组件，里面使用了原生 XHR ，没有遇到上传文件的问题，但是我在使用 jQuery 的 Ajax 时却怎么都办法上传，检查发现是 <code>content-type</code> 导致的问题。</p>
<a id="more"></a>
<p>仔细查看 jQuery 的 API 文档才发现原来它默认 <code>contentType</code> 为 <code>application/x-www-form-urlencoded</code> ，这显然不是 <code>FormData</code> 的类型。同时 <code>processData</code> 为了配合默认的 <code>contentType</code> 类型，也会把需要发送的 <code>data</code> 对象转为一个查询字符串。因此在发送一个 <code>FormData</code> 类型的数据时，应该这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type: <span class="string">'post'</span>,</span><br><span class="line">    url: <span class="string">'/api/upload'</span>,</span><br><span class="line">    contentType: <span class="literal">false</span>,</span><br><span class="line">    processData: <span class="literal">false</span>,</span><br><span class="line">    data: FormData,</span><br><span class="line">    success: handleResponse</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>前些天恰好遇到用 jQuery 提交一个上传的文件一直出错，这里记录一下原因。</p>
<p>我们的项目本身是使用了 vue 的，但是历史原因同时也保留了 jQuery ，然后项目中用 Promise 重新封装了 jQuery 的 Ajax 方法。之前有一个共用的 upload 的上传组件，里面使用了原生 XHR ，没有遇到上传文件的问题，但是我在使用 jQuery 的 Ajax 时却怎么都办法上传，检查发现是 <code>content-type</code> 导致的问题。</p>]]>
    
    </summary>
    
      <category term="Tips" scheme="http://zhaoshibo.net/tags/Tips/"/>
    
      <category term="jQuery" scheme="http://zhaoshibo.net/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTML5 图片预览]]></title>
    <link href="http://zhaoshibo.net/blog/2016/08/29/HTML5%20%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88/"/>
    <id>http://zhaoshibo.net/blog/2016/08/29/HTML5 图片预览/</id>
    <published>2016-08-29T14:43:12.000Z</published>
    <updated>2016-10-31T12:18:49.000Z</updated>
    <content type="html"><![CDATA[<p>在没有 HTML5 之前，前端的图片预览都是在用户选择图片后就发 Ajax 到服务端，然后由服务端再把图片的 URL 返还给前端来完成的。有了 HTML5 后，在 IE10 以上及代浏览器的版本中我们便无须发请求获得 URL 来完成预览了。这些将依靠 <code>FileReader</code> 来实现。</p>
<a id="more"></a>
<p>我们直接来实现一个 demo，可以点击尝试一下。</p>
<p><input id="file" type="file" accept="image/jpg, image/jpeg, image/png, image/gif"></p>
<div id="preview"></div>

<script>
var file = document.getElementById('file'),
    preview = document.getElementById('preview');
file.addEventListener('change', function(e) {
    var file = e.target.files[0],
        fr = new FileReader();
    fr.onload = function(e) {
        var img = e.target.result;
        preview.innerHTML = '<img src="' + img + '" width="200" height="200">';
    };
    fr.readAsDataURL(file);
}, false);
</script>


<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"file"</span> <span class="attribute">type</span>=<span class="value">"file"</span> <span class="attribute">accept</span>=<span class="value">"image/jpg, image/jpeg, image/png, image/gif"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">id</span>=<span class="value">"preview"</span> <span class="attribute">src</span>=<span class="value">""</span> <span class="attribute">width</span>=<span class="value">"200"</span> <span class="attribute">height</span>=<span class="value">"200"</span> <span class="attribute">style</span>=<span class="value">"display: none"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span>.getElementById(<span class="string">'file'</span>),</span><br><span class="line">    preview = <span class="built_in">document</span>.getElementById(<span class="string">'preview'</span>);</span><br><span class="line"></span><br><span class="line">file.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> file = e.target.files[<span class="number">0</span>],</span><br><span class="line">        fr = <span class="keyword">new</span> FileReader();</span><br><span class="line"></span><br><span class="line">    fr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        preview.src = e.target.result;</span><br><span class="line">        preview.style.display = <span class="string">'block'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fr.readAsDataURL(file);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们用 <code>FileReader</code> 的一个实例利用方法 <code>readAsDataURL</code> 读取了上传的文件，并且我们事先设置了在读取即 <code>onload</code> 时，触发了视图更新。</p>
<p><code>FileReader</code> 的这个特性，主要是把上传的图片给转化为了 <code>base64</code> 的格式，因此实现了预览。其实它还可以读取 <code>Blob</code> 和 <code>File</code> 等文件，具体的方法可以看<a href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader" target="_blank" rel="external">这里</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在没有 HTML5 之前，前端的图片预览都是在用户选择图片后就发 Ajax 到服务端，然后由服务端再把图片的 URL 返还给前端来完成的。有了 HTML5 后，在 IE10 以上及代浏览器的版本中我们便无须发请求获得 URL 来完成预览了。这些将依靠 <code>FileReader</code> 来实现。</p>]]>
    
    </summary>
    
      <category term="HTML5" scheme="http://zhaoshibo.net/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 的复制操作]]></title>
    <link href="http://zhaoshibo.net/blog/2016/08/17/Javascript%20%E7%9A%84%E5%A4%8D%E5%88%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://zhaoshibo.net/blog/2016/08/17/Javascript 的复制操作/</id>
    <published>2016-08-17T15:47:46.000Z</published>
    <updated>2017-04-24T10:47:01.000Z</updated>
    <content type="html"><![CDATA[<p>对于点击按钮就能复制一个链接或其他内容的操作，在很多网站都会有用到。使用原生的js方法 <code>document.execCommand</code> 即可实现，它能够对<strong>可以编辑的文档对象（设置contentEditable等）</strong>进行操作。</p>
<h2 id="语法">语法</h2><p>它的基本语法如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool = document.execCommand(aCommandName, aShowDefaultUI, aValueArgument)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>接受三个参数，并返回一个 <code>Boolean</code>，如果是 <code>false</code> 则表示操作不被支持或未被启用。</p>
<p>第一个参数是一个 <code>DOMString</code>，即为用到的命令名称，如 <code>copy</code>、<code>cut</code> 等，具体的实现因浏览器而异，目前多数的浏览器都能支持，可以<a href="http://codepen.io/netsi1964/full/QbLLGW/" target="_blank" rel="external"><strong>点此预览</strong></a>这些指令并检测当前浏览器是否支持。</p>
<p>第二个参数是一个 <code>Boolean</code> 是否展示用户界面，一般为 <code>false</code>。Mozilla 没有实现。实际使用中并未用到。</p>
<p>第三个参数是某些命令需要的一些额外参数值（如 insertimage 需要提供这个 image 的 url）。默认为 <code>null。</code>实际使用中也为用到。</p>
<h2 id="实现复制功能">实现复制功能</h2><p>对于一个页面中已经存在的 <code>input</code> 元素来讲，我们只需要直接对调用即可实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设页面存在以下元素</span></span><br><span class="line"><span class="comment">// &lt;input id="copy" type="text" value="copy command"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'copy'</span>).select()</span><br><span class="line"><span class="built_in">document</span>.execCommand(<span class="string">'copy'</span>)</span><br></pre></td></tr></table></figure>
<p>以上便把 “copy command” 这个内容复制到了剪切板内。对于这样的功能实现并不复杂，实际业务场景中若遇到点击一个叫做“复制链接”的按钮就直接复制到剪切板上，这就让人头疼了。我们很容易想到利用一下代码实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>)</span><br><span class="line">input.type = <span class="string">'text'</span></span><br><span class="line">input.value = someData	<span class="comment">// 一些数据</span></span><br><span class="line">input.select()</span><br><span class="line"><span class="built_in">document</span>.execCommand(<span class="string">'copy'</span>)</span><br><span class="line">input.blur()</span><br></pre></td></tr></table></figure>
<p>然而现实运行后却发现并没有成功。后来反复试验发现对于任何一个不可见的元素： <code>display: none</code>、<code>type=&quot;hidden&quot;</code>、<code>width: 0； height: 0</code> 等，该指令均无效。回头仔细研究基本语法，发现<strong>可编辑的文档对象</strong>似乎有什么猫腻，假设一个元素无法看见，或者无法点击，那么确实好像没办法<strong>直接编辑</strong>，所以这就是没有成功的原因了。但是非要实现这样一个功能怎么办呢，思前想后不妨试试 <code>opacity: 0</code>，这下竟然成功了。因此为了不影响UI的前提下可以这样实现功能。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">button</span> <span class="attribute">id</span>=<span class="value">"copyBtn"</span> <span class="attribute">type</span>=<span class="value">"button"</span>&gt;</span>复制链接<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/babel"</span>&gt;</span><span class="javascript"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'copyBtn'</span>)</span><br><span class="line">    .addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> _target = e.target</span><br><span class="line">        <span class="keyword">let</span> input = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>)</span><br><span class="line">        input.type = <span class="string">'text'</span></span><br><span class="line">        input.className = <span class="string">'copy-text'</span>   <span class="comment">// 利用 class 设置样式</span></span><br><span class="line">        input.value = someData          <span class="comment">// 一些数据</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> _i = _target.appendChild(input) <span class="comment">// 暂时添加进 button 节点中了，也可以放在其他地方</span></span><br><span class="line"></span><br><span class="line">        _i.select()</span><br><span class="line">        <span class="built_in">document</span>.execCommand(<span class="string">'copy'</span>)</span><br><span class="line"></span><br><span class="line">        _target.removeChild(_i)</span><br><span class="line">        input = <span class="literal">null</span></span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">style</span> <span class="attribute">lang</span>=<span class="value">"scss"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet/scss"</span>&gt;</span><span class="css"></span><br><span class="line"><span class="id">#copy-btn</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;</span><br><span class="line"></span><br><span class="line">    .copy-text &#123;</span><br><span class="line">        <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>; // 脱离文档流，防止对 UI 影响</span><br><span class="line">        <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">1px</span></span></span>;         // 没啥大用，强迫症：）</span><br><span class="line">        <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">1px</span></span></span>;        // 没啥大用，强迫症：）</span><br><span class="line">        <span class="rule"><span class="attribute">opacity</span>:<span class="value"> <span class="number">0</span></span></span>;         // 重点</span><br><span class="line">    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上便完成了直接点击按钮即复制一条需要的内容的需求。其实多数情况下防止代码复制无效，都会要显示出来要复制的内容的，只是最近恰好遇到了这样一个需求而已。</p>
<h2 id="总结">总结</h2><p>对于其他功能，都是类似实现，并不复杂，但是要注意只对<strong>可以编辑的文档对象</strong>可以使用。另外它的兼容性还可以了，对于我们不需要兼容低版本浏览器的 PC 端来讲不会有啥大问题，不过对于移动端可能会出现一些问题，比如 Safari 等的不支持，暂时没有用到就不讲了。</p>
<h2 id="参考资料">参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand#例子" target="_blank" rel="external">document.execCommand - Web API 接口 | MDN</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于点击按钮就能复制一个链接或其他内容的操作，在很多网站都会有用到。使用原生的js方法 <code>document.execCommand</code> 即可实现，它能够对<strong>可以编辑的文档对象（设置contentEditable等）</strong>进行操作。</p>
<h2 id="语法">语法</h2><p>它的基本语法如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool = document.execCommand(aCommandName, aShowDefaultUI, aValueArgument)</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://zhaoshibo.net/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery插件写法]]></title>
    <link href="http://zhaoshibo.net/blog/2016/07/17/jQuery%E6%8F%92%E4%BB%B6%E5%86%99%E6%B3%95/"/>
    <id>http://zhaoshibo.net/blog/2016/07/17/jQuery插件写法/</id>
    <published>2016-07-17T12:45:39.000Z</published>
    <updated>2016-10-31T12:18:49.000Z</updated>
    <content type="html"><![CDATA[<p>在当前的前端时代，react，vue等框架配合ES6满足了日常的多数开发需求，但是了解jQuery的插件开发在我们开发一些小型项目中还是很有用处。我们可以打造自己的插件达到复用的效果。</p>
<a id="more"></a>
<h2 id="extend方法">extend方法</h2><p>我们首先知道在jQuery中<code>$.fn === $.prototype</code>。如果只是简单的需要一个jQuery的扩展方法，那么我们直接使用<code>$.extend</code>即可达到目的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.extend(&#123;</span><br><span class="line">	min: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$.min(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>这种方法往往不是我们想要的，我们多数时候需要操作一个特定的dom从而使用一些自定义方法。这个时候就需要在jQuery的原型进行拓展，也就是这篇文章所要讨论的插件写法，将会使用到<code>$.fn.extend()</code>方法。</p>
<h2 id="外部容器">外部容器</h2><p>首先需要用一个立即执行的函数给我们的插件一个独立的作用域，防止冲突。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params">$, window, document, undefined</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// do sth.</span></span><br><span class="line">&#125;)(jQuery, <span class="built_in">window</span>, <span class="built_in">document</span>)</span><br></pre></td></tr></table></figure>
<p>这里把jQuery和系统全局变量传递给插件内部，系统变量在这里实现局部引用可以提高访问速度，<code>undefined</code>是为了得到一个没有修改的<code>undefined</code>，这里没有传第4个参数即是在那个位置得到了真实的<code>undefined</code>。最后我们在最前面加入<code>;</code>，是防止其他人的代码造成干扰从而报错无法运行。</p>
<h2 id="基本插件写法">基本插件写法</h2><p>有了容器，我们现在就需要定义我们自己的插件了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params">$, window, document, undefined</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 创建内部对象</span></span><br><span class="line">	<span class="keyword">var</span> Func = <span class="function"><span class="keyword">function</span> (<span class="params">el, opts</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.$el = $(el);</span><br><span class="line">		<span class="keyword">this</span>.opts = $.extend(&#123;&#125;, Func.DEFAULTS, opts);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// do sth.</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 内部对象的默认参数</span></span><br><span class="line">	Func.DEFAULTS = &#123;</span><br><span class="line">		key: <span class="string">'val'</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 内部对象的方法</span></span><br><span class="line">	Func.prototype = &#123;</span><br><span class="line">		init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	$.fn.extend(&#123;</span><br><span class="line">		pluginName: <span class="function"><span class="keyword">function</span> (<span class="params">opts</span>) </span>&#123;</span><br><span class="line">			<span class="comment">// 实现循环调用</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Func(<span class="keyword">this</span>, opts);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;)(jQuery, <span class="built_in">window</span>, <span class="built_in">document</span>)</span><br></pre></td></tr></table></figure>
<p>通过上面的代码，我们首先可以自定义自己的插件名字<code>pluginName</code>，以及插件内部需要实现的一些方法。用一个工厂模式来构造我们的方法<code>Func</code>，并且定义一些默认的参数。使用插件时传入对象参数时则更新内部的默认参数。这里暂时没有考虑内部其他方法的参数。</p>
<p>此时我们已经可以使用自定义好的插件了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'el'</span>).pluginName();</span><br><span class="line"><span class="comment">// $('el').pluginName(&#123;key: newVal&#125;); // 传入参数</span></span><br></pre></td></tr></table></figure>
<h2 id="向内部方法传参的插件写法">向内部方法传参的插件写法</h2><p>为了达到插件内部方法还能传参，我们可以在拓展插件时进行一些定义，在pluginName的方法返回值之前做一些判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Func.DEFAULTS = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> methods = &#123;</span><br><span class="line">	init: <span class="function"><span class="keyword">function</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">var</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>);</span><br><span class="line">			opts = $.extend(&#123;&#125;, Func.DEFAULTS, opts);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// do sth.</span></span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$.fn.pluginName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> method = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(methods[method]) &#123;</span><br><span class="line">		method = methods[method];</span><br><span class="line">		args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>( <span class="keyword">typeof</span>(method) == <span class="string">'object'</span> || !method ) &#123;</span><br><span class="line">		<span class="comment">// 使用init初始化数据，或者使用new Func()来实例化，则需要在Func内部做一些处理</span></span><br><span class="line">		method = methods.init;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		$.error( <span class="string">'方法不存在'</span> );</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> method.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在则可以通过第一个参数获取方法，之后的参数为该方法的参数来使用插件内部方法了。多数情况下，插件的具体实现以及关于可拓展性，我们会在上面2种方法中结合使用。</p>
<h2 id="单例模式的优化">单例模式的优化</h2><p>为了插件拥有更好的性能以及减少额外的开销，我们可以根据需要使用单例模式。同样在返回一个实例化对象时我们可以提前判断是否已经存在这么一个实例化对象了。这里简单的拿上述第一个结构为例子，在拓展插件时做一下判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$.fn.pluginName = <span class="function"><span class="keyword">function</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    	<span class="comment">// 单例模式</span></span><br><span class="line">        <span class="keyword">var</span> self = $(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">var</span> instance = self.data(<span class="string">'Func'</span>);</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Func(self, opts);</span><br><span class="line">            self.data(<span class="string">'Func'</span>, instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用插件上的方法，本文中第二种写法可以根据此自由拓展</span></span><br><span class="line">        <span class="keyword">if</span>($.type(opts) === <span class="string">'string'</span>) <span class="keyword">return</span> instance[opts]();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在判断实例对象时，我们利用了<code>data()</code>来存放插件对象的实例，同样利用该方法我们可以在<code>Func</code>的内部方法上提供一些数据存取。在不需要的时候使用<code>removeData()</code>来进行删除。</p>
<h2 id="总结">总结</h2><p>插件的写法在本篇文章做了总结，但是依然需要在实际开发中按需进行不同的搭配。并且在实际的开发中，一定要辅以一些设计模式，这样才能更好的组织代码，并提供更好的实践。</p>
<h2 id="参考资料">参考资料</h2><ol>
<li><a href="http://blog.jobbole.com/30550/" target="_blank" rel="external">深入理解jQuery插件开发</a></li>
<li><a href="http://www.cnblogs.com/Wayou/p/jquery_plugin_tutorial.html#!comments" target="_blank" rel="external">jQuery插件开发精品教程，让你的jQuery提升一个台阶</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>在当前的前端时代，react，vue等框架配合ES6满足了日常的多数开发需求，但是了解jQuery的插件开发在我们开发一些小型项目中还是很有用处。我们可以打造自己的插件达到复用的效果。</p>]]>
    
    </summary>
    
      <category term="jQuery" scheme="http://zhaoshibo.net/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[去除select等标签默认浏览器样式]]></title>
    <link href="http://zhaoshibo.net/blog/2016/07/17/%E5%8E%BB%E9%99%A4select%E7%AD%89%E6%A0%87%E7%AD%BE%E9%BB%98%E8%AE%A4%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A0%B7%E5%BC%8F/"/>
    <id>http://zhaoshibo.net/blog/2016/07/17/去除select等标签默认浏览器样式/</id>
    <published>2016-07-17T08:11:47.000Z</published>
    <updated>2016-10-31T12:18:49.000Z</updated>
    <content type="html"><![CDATA[<p>去除select等标签默认浏览器样式的方式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">select</span> <span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">-webkit-appearance</span>:<span class="value"> none</span></span>;  <span class="comment">/* chrome */</span></span><br><span class="line">	   <span class="rule"><span class="attribute">-moz-appearance</span>:<span class="value"> none</span></span>;  <span class="comment">/* firefox */</span></span><br><span class="line">	        <span class="rule"><span class="attribute">appearance</span>:<span class="value"> none</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* IE */</span></span><br><span class="line"><span class="tag">select</span><span class="pseudo">::-ms-expand</span> <span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">display</span>:<span class="value"> none</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>去除select等标签默认浏览器样式的方式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="l]]>
    </summary>
    
      <category term="CSS" scheme="http://zhaoshibo.net/tags/CSS/"/>
    
      <category term="Tips" scheme="http://zhaoshibo.net/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Flex布局]]></title>
    <link href="http://zhaoshibo.net/blog/2016/05/04/flex%E5%B8%83%E5%B1%80/"/>
    <id>http://zhaoshibo.net/blog/2016/05/04/flex布局/</id>
    <published>2016-05-04T00:06:01.000Z</published>
    <updated>2016-10-31T12:18:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Flexible_Box_Layout">Flexible Box Layout</h1><blockquote>
<p>CSS 弹性框布局是 CSS 的模块之一，定义了一种针对用户界面设计而优化的 CSS 框模型。在弹性布局模型中，弹性容器的子元素可以在任何方向上排布，也可以“弹性伸缩”其尺寸，既可以增加尺寸以填满未使用的空间，也可以收缩尺寸以避免父元素溢出。子元素的水平对齐和垂直对齐都能很方便的进行操控。通过嵌套这些框（水平框在垂直框内，或垂直框在水平框内）可以在两个维度上构建布局。</p>
</blockquote>
<a id="more"></a>
<p>弹性布局在定义方面是指调整其内项目宽高从而在任何显示设备上实现对可用显示空间最佳填充的能力。弹性容器扩展其内项目来填充可用空间，或将其收缩来避免溢出。</p>
<h2 id="1-_基本概念">1. 基本概念</h2><p><img src="http://7xlivs.com1.z0.glb.clouddn.com/2016/05/flex布局/flexbox.png" alt="flexbox"></p>
<p>容器默认存在两根轴：<code>main axis</code>（从<code>main-start</code>向<code>main-end</code>）或者<code>cross axis</code>（从<code>cross-start</code>向<code>cross-end</code>）。</p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的侧轴空间叫做<code>cross size</code>。</p>
<ul>
<li><strong>main axis</strong>：Flex容器的主轴主要用来配置Flex项目。它的方向取决于<code>flex-direction</code>属性。</li>
<li><strong>main-start</strong> | <strong>main-end</strong>：Flex项目的配置从容器的主轴起点边开始，往主轴终点边结束。</li>
<li><strong>main size</strong>：Flex项目的在主轴方向的宽度或高度就是项目的主轴长度，Flex项目的主轴长度属性是<code>width</code>或<code>height</code>属性，由哪一个对着主轴方向决定。</li>
<li><strong>cross axis</strong>：与主轴垂直的轴称作侧轴，是侧轴方向的延伸。</li>
<li><strong>cross-start</strong> | <strong>cross-end</strong>：伸缩行的配置从容器的侧轴起点边开始，往侧轴终点边结束。</li>
<li><strong>cross size</strong>：Flex项目的在侧轴方向的宽度或高度就是项目的侧轴长度，Flex项目的侧轴长度属性是<code>width</code>或<code>height</code>属性，由哪一个对着侧轴方向决定。</li>
</ul>
<h2 id="2-_外层父容器属性">2. 外层父容器属性</h2><p>定义一个Flex容器，根据其取的值来决定是内联还是块。Flex容器会为其内容建立新的伸缩格式化上下文。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">	display: flex | inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，Flex容器不是块容器，因此有些设计用来控制块布局的属性在Flexbox布局中不适用。特别是：多列组中所有<code>column-*</code>属性、<code>float</code>、<code>clear</code>属性和<code>vertical-align</code>属性在Flex容器上没有作用。</p>
<p>以下6个属性设置在父容器上。</p>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<h3 id="2-1_flex-direction">2.1 flex-direction</h3><p>弹性容器的各个边描述了弹性条目流的起点与终点。它们决定了弹性容器的主轴方向（从左到右、从右到左，等等）。</p>
<p><img src="http://7xlivs.com1.z0.glb.clouddn.com/2016/05/flex布局/flex-direction.png" alt="flex-direction"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  flex-direction: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
<h3 id="2-2_flex-wrap">2.2 flex-wrap</h3><p>默认情况之下，Flex项目都尽可能在一行显示。你可以根据flex-wrap的属性值来改变，让Flex项目多行显示。</p>
<p><img src="http://7xlivs.com1.z0.glb.clouddn.com/2016/05/flex布局/flex-wrap.png" alt="flex-wrap"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">   flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>nowrap(默认值)：不换行。</li>
<li>wrap：换行，第一行在<strong>下方</strong>。</li>
<li>wrap-reverse：换行，第一行在<strong>上方</strong>。</li>
</ul>
<h3 id="2-3_flex-flow">2.3 flex-flow</h3><p>这是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">   flex-flow: <span class="xml"><span class="tag">&lt;<span class="title">flex-direction</span>&gt;</span> || <span class="tag">&lt;<span class="title">flex-wrap</span>&gt;</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4_justify-content">2.4 justify-content</h3><p><img src="http://7xlivs.com1.z0.glb.clouddn.com/2016/05/flex布局/justify-content.png" alt="justify-content"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">   justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>flex-start（默认值）：左对齐。</li>
<li>flex-end：右对齐。</li>
<li>center：居中。</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
<h3 id="2-5_align-items">2.5 align-items</h3><p>定义项目在侧轴上如何对齐。</p>
<p><img src="http://7xlivs.com1.z0.glb.clouddn.com/2016/05/flex布局/align-items.png" alt="align-items"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">   align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>flex-start：侧轴的起点对齐。</li>
<li>flex-end：侧轴的终点对齐。</li>
<li>center：侧轴的中点对齐。</li>
<li>baseline：项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<h3 id="2-6_align-content">2.6 align-content</h3><p>定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<p><img src="http://7xlivs.com1.z0.glb.clouddn.com/2016/05/flex布局/align-content.png" alt="align-content"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">   align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>flex-start：与侧轴的起点对齐。</li>
<li>flex-end：与侧轴的终点对齐。</li>
<li>center：与侧轴的中点对齐。</li>
<li>space-between：与侧轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch（默认值）：轴线占满整个侧轴。</li>
</ul>
<h2 id="3-_子元素项目属性">3. 子元素项目属性</h2><p>以下6个属性设置在子项目上。</p>
<ul>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
<li>flex</li>
<li>align-self</li>
</ul>
<h3 id="3-1_order">3.1 order</h3><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0，有最小（负值最大）order的伸缩项目排在第一个。</p>
<p><img src="http://7xlivs.com1.z0.glb.clouddn.com/2016/05/flex布局/order.png" alt="order"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">	order: <span class="xml"><span class="tag">&lt;<span class="title">integer</span>&gt;</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2_flex-grow">3.2 flex-grow</h3><p>定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p>
<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<p><img src="http://7xlivs.com1.z0.glb.clouddn.com/2016/05/flex布局/flex-grow.png" alt="flex-grow"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">	flex-grow: <span class="xml"><span class="tag">&lt;<span class="title">number</span>&gt;</span>;</span> <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3_flex-shrink">3.3 flex-shrink</h3><p>定义了项目的缩小比例，默认为1(负值无效)，即如果空间不足，该项目将缩小。</p>
<p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<p><img src="http://7xlivs.com1.z0.glb.clouddn.com/2016/05/flex布局/flex-shrink.jpg" alt="flex-shrink"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">	flex-shrink: <span class="xml"><span class="tag">&lt;<span class="title">number</span>&gt;</span>;</span> <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4_flex-basis">3.4 flex-basis</h3><p>定义了Flex项目在分配Flex容器剩余空间之前的一个默认尺寸。<code>main-size</code>值使它具有匹配的宽度或高度，不过都需要取决于<code>flex-direction</code>的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-basis: <span class="xml"><span class="tag">&lt;<span class="title">length</span>&gt;</span> | auto; /* default auto */</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5_flex">3.5 flex</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex: none | [ <span class="xml"><span class="tag">&lt;<span class="title">'flex-grow'</span>&gt;</span> <span class="tag">&lt;<span class="title">'flex-shrink'</span>&gt;</span>? || <span class="tag">&lt;<span class="title">'flex-basis'</span>&gt;</span> ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议使用简写属性，而不是设置单独属性。</p>
<ul>
<li>auto (1 1 auto)</li>
<li>none (0 0 auto)。</li>
</ul>
<h3 id="3-6_align-self">3.6 align-self</h3><p>允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p>
<p><img src="http://7xlivs.com1.z0.glb.clouddn.com/2016/05/flex布局/align-self.png" alt="align-self"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">	align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>flex-start：侧轴的起点对齐。</li>
<li>flex-end：侧轴的终点对齐。</li>
<li>center：侧轴的中点对齐。</li>
<li>baseline：项目的第一行文字的基线对齐。</li>
<li>stretch：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<h2 id="4-_兼容性">4. 兼容性</h2><iframe width="100%" height="380" src="http://caniuse.com/flexbox/embed"></iframe>

<ul>
<li>iOS和Android4.4以上可以使用最新的flex布局</li>
<li>Android4.4以下兼容旧版flexbox布局</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: <span class="string">-webkit-box;</span></span><br><span class="line"><span class="attribute">display</span>: <span class="string">-webkit-flex;</span></span><br><span class="line"><span class="attribute">display</span>: <span class="string">-ms-flexbox;</span></span><br><span class="line"><span class="attribute">display</span>: <span class="string">flex;</span></span><br><span class="line"></span><br><span class="line"><span class="less"><span class="attribute">-webkit-box-flex</span>: <span class="number">1</span>;</span><br><span class="line">	<span class="attribute">-webkit-flex</span>: <span class="number">1</span>;</span><br><span class="line">	    <span class="attribute">-ms-flex</span>: <span class="number">1</span>;</span><br><span class="line">	        <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">-webkit-box-pack</span>: center;</span><br><span class="line">	<span class="attribute">-webkit-justify-content</span>: center;</span><br><span class="line">	    <span class="attribute">-ms-flex-pack</span>: center;</span><br><span class="line">	        <span class="attribute">justify-content</span>: center;</span><br><span class="line"></span><br><span class="line"><span class="attribute">-webkit-box-align</span>: center;</span><br><span class="line">	<span class="attribute">-webkit-align-items</span>: center;</span><br><span class="line">	    <span class="attribute">-ms-flex-align</span>: center;</span><br><span class="line">	        <span class="attribute">align-items</span>: center;</span></span><br></pre></td></tr></table></figure>
<h2 id="5_参考资料">5 参考资料</h2><ol>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">Flex 布局教程：语法篇</a></li>
<li><a href="http://www.w3cplus.com/css3/a-guide-to-flexbox-new.html" target="_blank" rel="external">一个完整的Flexbox指南</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Flexible_Box_Layout">Flexible Box Layout</h1><blockquote>
<p>CSS 弹性框布局是 CSS 的模块之一，定义了一种针对用户界面设计而优化的 CSS 框模型。在弹性布局模型中，弹性容器的子元素可以在任何方向上排布，也可以“弹性伸缩”其尺寸，既可以增加尺寸以填满未使用的空间，也可以收缩尺寸以避免父元素溢出。子元素的水平对齐和垂直对齐都能很方便的进行操控。通过嵌套这些框（水平框在垂直框内，或垂直框在水平框内）可以在两个维度上构建布局。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="CSS3" scheme="http://zhaoshibo.net/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于CSS3的3D属性]]></title>
    <link href="http://zhaoshibo.net/blog/2016/01/31/%E5%85%B3%E4%BA%8ECSS3%E7%9A%843D%E5%B1%9E%E6%80%A7/"/>
    <id>http://zhaoshibo.net/blog/2016/01/31/关于CSS3的3D属性/</id>
    <published>2016-01-31T10:05:19.000Z</published>
    <updated>2016-10-31T12:18:49.000Z</updated>
    <content type="html"><![CDATA[<p>关于CSS3的3D变换，属于一接触就能让人倍感兴趣的属性。参考了一些网上的资料，做一些总结，这里只讨论遇到的可使用的属性。</p>
<a id="more"></a>
<h3 id="rotate旋转">rotate旋转</h3><p>在此之前，我们首先建立一个3D的概念，在电脑上，我们看得到也最好理解的便是XY轴。屏幕自左向右为X轴，则沿着X轴的上下旋转即为<code>rotateX</code>；屏幕自上向下为Y轴，则沿着Y轴左右旋转即为<code>rotateY</code>；以屏幕为水平面，眼睛看向电脑的现实水平方向则为Z轴（可以想象为一条线从屏幕中水平穿出来），则沿着Z轴的旋转为<code>rotateZ</code>。有了这些概念再来看一个在平时2D的CSS3中从未使用过的<code>translateZ</code>属性。</p>
<p><img src="http://7xlivs.com1.z0.glb.clouddn.com/2016%2F01%2F%E5%85%B3%E4%BA%8ECSS3%E7%9A%843D%E5%B1%9E%E6%80%A7%2Frotate.jpg" alt="rotate旋转演示"></p>
<h3 id="translateZ位移">translateZ位移</h3><p>理解了旋转的话，那么位移这个属性实在是简单多了。既然Z轴可以理解为从显示器发射出来的那条线，那么沿着这条线往外位移，也就是向靠近眼睛方向的移动为translateZ(正数)，反之参数为负数，也就是远离你的眼睛。</p>
<p><img src="http://7xlivs.com1.z0.glb.clouddn.com/2016%2F01%2F%E5%85%B3%E4%BA%8ECSS3%E7%9A%843D%E5%B1%9E%E6%80%A7%2FtranslateZ.jpg" alt="translateZ位移演示"></p>
<h3 id="perspective透视">perspective透视</h3><p><code>perspective</code>指的是透视，在3D设置中起着幕布布景的含义。这个属性应用于父元素也就是舞台元素上，设置的参数意味着你的眼睛距离屏幕图像的距离，如<code>perspective： 200px</code>，则意味着你再距离屏幕200像素的距离观察图像。</p>
<p>假设父元素中设置<code>perspective： 200px</code>，此时在子元素中设置<code>tranzlateZ</code>的值越小，则越深入屏幕内部，相当于现实中物体远离眼睛，看到的物体也越小，相反，值越接近200px，则物体看起来越大。如果超过这个值那就相当于到了我们的脑后了，则什么也就看不到了。关于旋转，也等同于现实中远近距离下观察到的角度。</p>
<p>提到把“我们个人”作为观察者，就不得不提关于观察点的设置——<code>perspective-origin</code>，即我们眼睛所看到的中心点。这个值默认为图像的中心点，如果设置<code>perspective-origin： 25% 50%</code>；则意味着在图像中心点上方一半距离的位置。</p>
<h3 id="preserve-3d">preserve-3d</h3><p>在子元素上设置<code>transform-style: preserve-3d</code>就是为它们配置3D效果，另一个参数<code>flat</code>暂时没有遇到，不做讨论。这个属性一般设置在3D变换元素的父元素上即舞台元素上。该效果设置后，图像旋转位移等的表现形式为相对于你在现实世界中的表现类似于看镜子。</p>
<h3 id="backface-visibility">backface-visibility</h3><p>默认情况当多个图像重叠时，我们会透视看到后面的图像，与现实表现不符。因此设置<code>backface-visibility： hidden</code>，则可以让其与现实表现一致，即被遮挡的部分我们看不到。</p>
<h3 id="应用">应用</h3><p>大致情况下的HTML结构为：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> 父元素（舞台元素）（增加一定的视距 perspective）</span><br><span class="line"></span>	-<span class="ruby"> <span class="number">3</span>D容器(声明 transform-<span class="symbol">style:</span> preserve-<span class="number">3</span>d)</span><br><span class="line"></span>		-<span class="ruby"> 图片等元素（需要<span class="number">3</span>D效果的元素）</span><br><span class="line"></span>		-<span class="ruby"> 图片等元素</span><br><span class="line"></span>		-<span class="ruby"> 若干...</span></span><br></pre></td></tr></table></figure>
<p>示例一个简单的3D旋转导航栏效果：<a href="http://www.zhaoshibo.net/mydemo/demo/3D旋转导航栏.html" target="_blank" rel="external">Click Me！</a></p>
<p>本文知识面比较浅，单纯的记录了各属性如何使用，还有很多细节需要动手实践才能发现。比如<code>transform</code>多属性时，旋转和位移等属性的书写顺序也会影响结果，不过根据这个顺序也可以做出其他的变换。不多说，多实践才可行。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于CSS3的3D变换，属于一接触就能让人倍感兴趣的属性。参考了一些网上的资料，做一些总结，这里只讨论遇到的可使用的属性。</p>]]>
    
    </summary>
    
      <category term="CSS3" scheme="http://zhaoshibo.net/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS3 text-shadow在IE下的解决]]></title>
    <link href="http://zhaoshibo.net/blog/2016/01/12/IE9%E5%8F%8A%E4%BB%A5%E4%B8%8B%E7%9A%84%E6%96%87%E5%AD%97%E9%98%B4%E5%BD%B1/"/>
    <id>http://zhaoshibo.net/blog/2016/01/12/IE9及以下的文字阴影/</id>
    <published>2016-01-12T10:09:07.000Z</published>
    <updated>2016-10-31T12:18:49.000Z</updated>
    <content type="html"><![CDATA[<p><code>text-shadow</code>兼容IE10及FF3.5以上，在IE8、9下可以使用滤镜<code>filter：glow</code>使元素发光来替代。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">filter</span>： <span class="tag">grow</span>(<span class="tag">color</span>: <span class="id">#000</span>, <span class="tag">strength</span>: 1);</span><br><span class="line"><span class="tag">filter</span>： <span class="tag">grow</span>(<span class="tag">color</span>: <span class="id">#000</span>, <span class="tag">direction</span>: 2);</span><br></pre></td></tr></table></figure>
<p><code>color</code>设置发光颜色，在这里<code>strength</code>和<code>direction</code>均设置阴影强度，但它们2个的表现也不太一样。</p>
<p>在IE7以下这个属性暂时无效。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><code>text-shadow</code>兼容IE10及FF3.5以上，在IE8、9下可以使用滤镜<code>filter：glow</code>使元素发光来替代。</p>
<figure class="highlight css"><table><tr><td cl]]>
    </summary>
    
      <category term="CSS3" scheme="http://zhaoshibo.net/tags/CSS3/"/>
    
      <category term="Tips" scheme="http://zhaoshibo.net/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015 年终总结]]></title>
    <link href="http://zhaoshibo.net/blog/2016/01/03/2015%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://zhaoshibo.net/blog/2016/01/03/2015年度总结/</id>
    <published>2016-01-03T07:33:28.000Z</published>
    <updated>2017-01-05T10:10:13.000Z</updated>
    <content type="html"><![CDATA[<p>2015年是我的本命年，阳历年已经过去了，阴历年也只剩1月有余。而过去的这一年更是我人生工作的转折点。要说生活，想必也算是在2015踏上了正轨。</p>
<a id="more"></a>
<h3 id="一家小公司的历练">一家小公司的历练</h3><p>5月之前的时候我还是在一家仅有10人的小公司，在这家公司总共呆了8个月。入职这家公司是我毕业来到上海的第一年，当时我已经确认了我想做前端的方向，却不想事与愿违，以技术身份入职公司不足半月，因公司的业务倾向从而让我开始从事电商的方向了。当时还总是想着应届生还是老老实实呆满一年再做跳槽等的其他打算吧，当然其实内心深处也是有想体验其他职位的想法的。却不想在这里经历了一而再再而三的轮岗，让我无比心累。说明一下，公司在我所听到和所经历到的时间中，从未看到过任何收益。</p>
<p>不得不说这家公司的很多理念其实我挺喜欢的，只是老板总是在一个目标没有完成或者开始一大半的时候就突然中断并开始另一个新的目标，而且总是在夸夸其谈各种伟大的抱负。更让人无法接受的是在过年前还拖欠了2个月的工资，在我们所有员工轮流催促下总算是在除夕夜前拿到了这笔薪资。不过在我离职的时候，从过完年2月到4月的工资却又硬生生的拖欠到了7月我才拿到手。而此时据我所知最后2个在去年8月离职的同事可能还有欠款未结。离职之后其实我有通过12333投诉过，包括社保和工资的问题，其实也正是因此才有了解决。说到社保老板最后竟然把所有人入职前谈到的税后工资硬生生的说成是税前工资了，其实离职的那次谈话我是有录音的（在此提醒各位在必要的时候做好证据收集），只是后来入职现在的公司后实在觉得不值得再花时间去讨要损失了。</p>
<p>这是一份非常不愉快的工作经历。不过从这份工作，我也再次坚定了我的前端方向，从2月份之后我就开始不断学习着前端的知识了。另外这也是一份教训和经验，如果一份工作入职后却发现完全事与愿违，一定要早早换工作，千万不要被老板所画的饼诱惑；另外签合同一定要核对清楚，不要因为尴尬而不敢核对。</p>
<h3 id="前端工作">前端工作</h3><p>5月份面试了一份工作我便来了现在的公司，说实话当时确实太武断了，不过的确迫于生计，实在没有任何办法了。公司当时也是缺人，需要一个能兼做技术支持的前端，而我也是考虑到个人没有过前端经验，需要这个进入圈子的机会。无论如何，我都很感谢现在公司给我的机会。</p>
<p>公司没有很多项目，自家做的也是电商产品，是几款管理淘宝店铺宝贝、辅助开店并提供货源等功能的软件。很多时候前端的内容并不太多，前端的员工也只有3个。因为我兼做技术支持的原因，我所接触的项目也只是公司官网及周边一些网站的维护。正因为如此，没有项目，也没有人带，自己摸索着开始切图、开始写页面、会使用jq、开始更加注重js……这是一个完全靠自学的过程。我负责了很多网站的小需求，诸如改个轮播、加个货源展示页面或者重新把pc和移动端页面更改一遍（非完全重构）等等。所有这些需求有个共同点，就是并不太难，而且公司重心在软件产品上，并不太重视所有网站的布局等（只要能卖出东西就行）。因此出现了大量的克隆网站，同时这些网站连个管理工具都没有，每次改完只能直接覆盖在服务器上。其实说这些并非是抱怨，反而是这些看似最简单的工作，让我真正开始踏上了前端的道路，也正是这些小需求，从而让我开始自我约束，开始在改页面的时候想尽办法更语义化规范化。有的时候一周结束到周五的时候，后端和前端会在一起开个总结的会，每到这时候都是我最尴尬的时候，因为我的总结总是技术支持和网站需求更改，而其他人却是和软件有关的任务。其实我真的挺渴望有个项目，起码到现在我依旧能接受有项目哪怕连续加班都可以。</p>
<p>没有机会就自己创造机会，从现在的公司到现在已经快9个月的时间了，我开始只会写简单的静态页面，到后来，我明白了一些命名规范，熟练了css，学会用jq或者js写当前网站最常用的小功能，学会使用fiddler，再到尝试深入js，了解了更多的基本和进阶技能，再后来会使用svn，学会了git，学会使用github，搭建自己的<a href="http://zhaoshibo.net">博客</a>，学会markdown写文章，学会使用gulp自动化构建工具以及相关的一些插件，学会sass预处理css，还有CSS3和HTML5等等。我也尝试使用bootstrap和angularjs，不幸因为没有项目半途放弃了，不过下一步目标还是会去接触MV*的框架。这半年多以来大致收获了这么多的知识，我知道这些可能还不够一个初级的前端，不过我还在努力着。平时写一些简单的<a href="http://zhaoshibo.net/mydemo">demo</a>练练手，以后还是要在github上增加一些复杂的demo了。另外新的一年在博客的产出也要多起来。</p>
<h3 id="最后">最后</h3><p>2015年是我收获最多也更加努力的一年，不过还是有些许遗憾，没有完全完成年初的计划。不过现在的生活已然是我最开心也最乐意接受的样子了，3月份的时候家里还来了新的小伙伴——一只美美哒泰迪，给生活更是增加了很多欢乐。</p>
<p>2016继续努力前行，希望能接触更多的项目，能够精进技术，考驾照，学吉他，健身，希望美好的目标都能够通过努力得到。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2015年是我的本命年，阳历年已经过去了，阴历年也只剩1月有余。而过去的这一年更是我人生工作的转折点。要说生活，想必也算是在2015踏上了正轨。</p>]]>
    
    </summary>
    
      <category term="生活" scheme="http://zhaoshibo.net/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个简单JS迭代器的总结]]></title>
    <link href="http://zhaoshibo.net/blog/2015/12/18/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95JS%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://zhaoshibo.net/blog/2015/12/18/一个简单JS迭代器的总结/</id>
    <published>2015-12-18T03:29:34.000Z</published>
    <updated>2016-10-31T12:18:49.000Z</updated>
    <content type="html"><![CDATA[<p>近来一直在<a href="http://www.codewars.com" target="_blank" rel="external">codewars</a>上练习JS，遇到了一个关于迭代的问题<a href="http://www.codewars.com/kata/54b679eaac3d54e6ca0008c9/train/javascript" target="_blank" rel="external">Function iteration</a>。原题目如下：</p>
<a id="more"></a>
<blockquote>
<p>The purpose of this kata is to write a higher-order function which is capable of creating a function that iterates on a specified function a given number of times. This new functions takes in an argument as a seed to start the computation from.</p>
<p>For instance, consider the function <code>getDouble</code>. When run twice on value <code>3</code>, yields <code>12</code> as shown below.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getDouble</span><span class="params">(<span class="number">3</span>)</span></span> =&gt; <span class="number">6</span></span><br><span class="line"><span class="function"><span class="title">getDouble</span><span class="params">(<span class="number">6</span>)</span></span> =&gt; <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>Let us name the new function <code>createIterator</code> and we should be able to obtain the same result using <code>createIterator</code> as shown below:</p>
<p>var doubleIterator = createIterator(getDouble, 2); // This means, it runs <em>getDouble</em> twice<br>doubleIterator(3) =&gt; 12</p>
<p>For the sake of simplicity, all function inputs to createIterator would be functions returning a small number and number of iterations would always be integers.</p>
</blockquote>
<p>开始的时候一直没有理解如何复用函数的返回值，索性在<code>createIterator(func, n)</code>中直接<code>return</code>函数<code>func</code>了。但是后来发现要验证的答案格式如下。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getDouble = function(n) &#123;</span><br><span class="line">    <span class="keyword">return</span> n + n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// <span class="type">Running</span> the <span class="keyword">iterator</span> <span class="keyword">for</span> once</span><br><span class="line"><span class="keyword">var</span> doubleIterator = createIterator(getDouble, <span class="number">1</span>);</span><br><span class="line">doubleIterator(<span class="number">3</span>); // =&gt; <span class="number">6</span></span><br><span class="line">doubleIterator(<span class="number">5</span>); // =&gt; <span class="number">10</span></span><br><span class="line"></span><br><span class="line">// <span class="type">Running</span> the <span class="keyword">iterator</span> twice</span><br><span class="line"><span class="keyword">var</span> getQuadruple = createIterator(getDouble, <span class="number">2</span>);</span><br><span class="line">getQuadruple(<span class="number">2</span>); // =&gt; <span class="number">8</span></span><br><span class="line">getQuadruple(<span class="number">5</span>); // =&gt; <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>一步步去思考，这里假设为需要运行2次。则最终<code>getQuadruple</code>需要内部调用函数2次，因此简单的就是使用循环来达到目的。索性先去根据理解写出想法。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createIterator = <span class="function"><span class="keyword">function</span> <span class="params">(func, n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Write code here to return a function </span></span><br><span class="line">  <span class="comment">// that executes *func*, *n* times on a supplied input</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            func(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>写到这里，怎么都不明白如何去写闭包中的返回值了。苦苦挣扎一下午还是参考了别人的思路，于是得出了正确代码。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createIterator = <span class="function"><span class="keyword">function</span> <span class="params">(func, n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Write code here to return a function </span></span><br><span class="line">  <span class="comment">// that executes *func*, *n* times on a supplied input</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arg = func(arg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arg;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从这里可以看出，在下一次循环所执行函数中的参数是上一次执行函数后得到的结果，因此便达到了迭代的目的，最终返回这个参数即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>近来一直在<a href="http://www.codewars.com">codewars</a>上练习JS，遇到了一个关于迭代的问题<a href="http://www.codewars.com/kata/54b679eaac3d54e6ca0008c9/train/javascript">Function iteration</a>。原题目如下：</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://zhaoshibo.net/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[callee、caller、call和apply]]></title>
    <link href="http://zhaoshibo.net/blog/2015/10/16/callee%E3%80%81caller%E3%80%81call%E5%92%8Capply/"/>
    <id>http://zhaoshibo.net/blog/2015/10/16/callee、caller、call和apply/</id>
    <published>2015-10-16T10:27:01.000Z</published>
    <updated>2016-10-31T12:18:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_callee">1. callee</h2><p><code>callee</code>，返回正在执行的函数本身的引用，是<code>arguments</code>的一个属性。只有在函数执行时有效；有一个<code>length</code>属性，可用于获得形参的个数，来比较是否和实参个数一致，即比较<code>arguments.length == arguments.callee.length</code>；还可用于递归匿名参数；可以用来消除耦合。</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不用()()立即执行时，则无效。</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">center</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee);		<span class="comment">// &gt; center()</span></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee);	<span class="comment">// &gt; inner()</span></span><br><span class="line">		&#125;</span><br><span class="line">		inner();</span><br><span class="line">	&#125;</span><br><span class="line">	center();</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h2 id="2-_caller">2. caller</h2><p><code>caller</code>，返回一个对函数的引用，该函数调用了当前的函数。只有在函数执行时有效；如果函数由顶层调用，那么返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不用()()立即执行时，则无效。</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">center</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">// 调用当前作用域，此时center.caller指向outer</span></span><br><span class="line">		<span class="comment">// center.caller可用arguments.callee.caller表示</span></span><br><span class="line">		<span class="built_in">console</span>.log(center.caller);			<span class="comment">// &gt; outer</span></span><br><span class="line">		<span class="built_in">console</span>.log(outer.caller);			<span class="comment">// &gt; null</span></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(inner.caller);		<span class="comment">// &gt; center()</span></span><br><span class="line">			<span class="built_in">console</span>.log(center.caller);		<span class="comment">// &gt; outer()</span></span><br><span class="line">			<span class="built_in">console</span>.log(outer.caller);		<span class="comment">// &gt; null</span></span><br><span class="line">		&#125;</span><br><span class="line">		inner();</span><br><span class="line">	&#125;</span><br><span class="line">	center();</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h2 id="3-_call&amp;apply">3. call&amp;apply</h2><p>每个函数都包含两个非继承的方法，<code>call</code>和<code>apply</code>。他们的用途都是在特定的作用域中调用函数，获取了另一个对象的方法，并继承对象的属性，只是接收的参数格式不同。它们的重要作用在于能够扩充函数的作用域，而且对象不需要与函数有任何的耦合。</p>
<ul>
<li><code>function.call(obj, arg1, arg2, ...)</code></li>
<li><code>function.apply(obj, [param1, param2, ...])</code></li>
<li><code>obj</code>将代替函数中的<code>this</code>对象</li>
<li><code>call</code>中第二个参数是一个参数列表</li>
<li><code>apply</code>中第二个参数是一个数组，用来传参给函数中的<code>arguments</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params">name, size</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.size = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Boxes</span>(<span class="params">name, size, number</span>)</span>&#123;</span><br><span class="line">	Box.call(<span class="keyword">this</span>, name, size);</span><br><span class="line">	<span class="comment">// Box.apply(this, arguments);</span></span><br><span class="line">	<span class="keyword">this</span>.number = number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mybox = <span class="keyword">new</span> Boxes(<span class="string">'mybox'</span>, <span class="string">'5*5*5'</span>, <span class="number">1001</span>);</span><br><span class="line"><span class="comment">// boxes中并未给name和size属性赋值，但是还是显示了预期结果，否则应为undefined</span></span><br><span class="line">alert(<span class="string">'name: '</span> + mybox.name + <span class="string">'\nsize: '</span> + mybox.size + <span class="string">'\nnumber: '</span> + mybox.number);</span><br></pre></td></tr></table></figure>
<p>使用时，如果希望输出结果的参数位置改变，如为<code>Boxes（size, name, number）</code>，则使用<code>call</code>更方便<code>Box.call(this, size， name)</code>。而需要按照顺序对应的情况下，使用<code>apply</code>的数组参数<code>arguments</code>则更方便。</p>
<h2 id="4-_其他一些高级用法">4. 其他一些高级用法</h2><p>对于<code>apply</code>和<code>call</code>，还有一些特别的用法，鉴于它两并无太大区别，这里以<code>apply</code>为例。个人总结该用法如下，非标准表达：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Fun</span><span class="class">.apply</span>(<span class="tag">Obj</span>, <span class="tag">arguments</span>);</span><br></pre></td></tr></table></figure>
<p>解释为，Obj对象调用Fun内部提供的方法，对arguments参数进行操作，此处，Obj对象可为this，null等。此方法颇适用于需要传入列表而非数组表达的参数时，即<code>param1, parram2, param3, ...</code>而非<code>[param1, param2, param3, ...]</code>时。</p>
<p>以下三个示例，分别展示了表达式中Obj，Fun和arguments的含义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> maxNum1 = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr);</span><br><span class="line"><span class="keyword">var</span> maxNum2 = <span class="built_in">Math</span>.max.apply(maxNum, arr);</span><br><span class="line"><span class="built_in">console</span>.log(maxNum1);</span><br><span class="line"><span class="built_in">console</span>.log(maxNum2);</span><br><span class="line"><span class="comment">// 结果都为5，这里更方便理解apply接收的第一个参数的含义</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Arr</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> vals = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//此处表达vals对象调用了apply前面所示数组的push方法，等价于下面注释掉的表达方法</span></span><br><span class="line">	vals.push.apply(vals, <span class="built_in">arguments</span>);</span><br><span class="line">	<span class="comment">// Array.prototype.push.apply(vals, arguments);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> vals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> Arr(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params">name, size</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Boxes</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Box.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aB = <span class="keyword">new</span> Boxes(<span class="string">'aBox'</span>, <span class="string">'5*5*5'</span>);</span><br><span class="line"><span class="keyword">var</span> bB = <span class="keyword">new</span> Boxes(<span class="string">'bBox'</span>, <span class="string">'sth else'</span>, <span class="string">'blah blah'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(aB);  <span class="comment">// Boxes &#123;name: "aBox", size: "5*5*5"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(bB);  <span class="comment">// Boxes &#123;name: "bBox", size: "sth else"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里可以看最后的参数调用Box的方法时，如果没有提供方法，则不会进行操作</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-_callee">1. callee</h2><p><code>callee</code>，返回正在执行的函数本身的引用，是<code>arguments</code>的一个属性。只有在函数执行时有效；有一个<code>length</code>属性，可用于获得形参的个数，来比较是否和实参个数一致，即比较<code>arguments.length == arguments.callee.length</code>；还可用于递归匿名参数；可以用来消除耦合。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://zhaoshibo.net/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[object标签和embed标签]]></title>
    <link href="http://zhaoshibo.net/blog/2015/09/25/object%E6%A0%87%E7%AD%BE%E5%92%8Cembed%E6%A0%87%E7%AD%BE/"/>
    <id>http://zhaoshibo.net/blog/2015/09/25/object标签和embed标签/</id>
    <published>2015-09-25T07:21:51.000Z</published>
    <updated>2016-10-31T12:18:49.000Z</updated>
    <content type="html"><![CDATA[<p>最近用到.swf的文件，一时不知如何调用，搜索后知道可以使用<code>object</code>标签或者<code>embed</code>标签来嵌入，参照着其他代码改完后，马马虎虎可以使用了。今天特意整理了其中的一些说明。原网页使用的代码如下：</p>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">object</span> <span class="attribute">classid</span>=<span class="value">"clsid:d27cdb6e-ae6d-11cf-96b8-444553540000"</span> <span class="attribute">codebase</span>=<span class="value">"&lt;a href='http://www.adobe.com/go/getflash'&gt;&lt;img src='images/TB21HgpbFXXXXX2XpXXXXXXXXXX_!!163498746.gif' alt='获得 Adobe Flash Player' /&gt;&lt;/a&gt;"</span> <span class="attribute">width</span>=<span class="value">"100%"</span> <span class="attribute">height</span>=<span class="value">"352"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"movie"</span> <span class="attribute">value</span>=<span class="value">"1.swf"</span> <span class="attribute">id</span>=<span class="value">"movie"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"wmode"</span> <span class="attribute">value</span>=<span class="value">"transparent"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"quality"</span> <span class="attribute">value</span>=<span class="value">"high"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"bgcolor"</span> <span class="attribute">value</span>=<span class="value">"#e1f7ff"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"play"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"loop"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"scale"</span> <span class="attribute">value</span>=<span class="value">"showall"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"menu"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"devicefont"</span> <span class="attribute">value</span>=<span class="value">"false"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"salign"</span> <span class="attribute">value</span>=<span class="value">""</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"allowScriptAccess"</span> <span class="attribute">value</span>=<span class="value">"sameDomain"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">embed</span> <span class="attribute">src</span>=<span class="value">"1.swf"</span> <span class="attribute">wmode</span>=<span class="value">"transparent"</span> <span class="attribute">quality</span>=<span class="value">"high"</span> <span class="attribute">bgcolor</span>=<span class="value">"#e1f7ff"</span> <span class="attribute">loop</span>=<span class="value">"true"</span> <span class="attribute">scale</span>=<span class="value">"showall"</span> <span class="attribute">menu</span>=<span class="value">"true"</span> <span class="attribute">devicefont</span>=<span class="value">"false"</span> <span class="attribute">allowScriptAccess</span>=<span class="value">"sameDomain"</span> <span class="attribute">width</span>=<span class="value">"100%"</span> <span class="attribute">height</span>=<span class="value">"352"</span> <span class="attribute">type</span>=<span class="value">"application/x-shockwave-flash"</span> <span class="attribute">pluginspage</span>=<span class="value">"&lt;a href='http://www.adobe.com/go/getflash'&gt;&lt;img src='images/TB21HgpbFXXXXX2XpXXXXXXXXXX_!!163498746.gif' alt='获得 Adobe Flash Player' /&gt;&lt;/a&gt;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">object</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里同时使用了<code>object</code>和<code>embed</code>标签来嵌入，目的是为了浏览器的兼容性。因此这两种写法对应的属性和参数要一致。</p>
<p>下面记录一些属性的意义。</p>
<h3 id="必需属性">必需属性</h3><ul>
<li><code>classid</code>，设置浏览器的AcriveX控件，与上述使用代码必须一致，仅用于<code>object</code>。</li>
<li><code>codebase</code>，设置flash插件的下载地址，若浏览器未安装，可自动下载安装，仅用于<code>object</code>。</li>
<li><code>width</code>和<code>height</code>，设置文件的宽度和高度，以百分比或像素表示。</li>
<li><code>movie</code>，设置文件地址，仅用于<code>object</code>。</li>
<li><code>pluginspage</code>，设置flash插件的下载地址，若浏览器未安装，可自动下载安装，仅用于<code>embed</code>。</li>
<li><code>src</code>，设置文件地址，仅用于<code>embed</code>。</li>
</ul>
<h3 id="可选属性">可选属性</h3><ul>
<li><code>wmode</code>，设置文件的window mode属性，指定文件在浏览器中的透明，层叠及位置。<ul>
<li><code>window</code>，文件在浏览器中自己的矩形窗口内播放。</li>
<li><code>opaque</code>，文件隐藏了所有在它后面的内容。</li>
<li><code>transparent</code>，文件透明，显示文件后面的网页内容，将会降低动画性能，且并不适用于所有浏览器。</li>
</ul>
</li>
<li><code>quality</code><ul>
<li><code>low</code>，速度优于美观，但不应用反锯齿。</li>
<li><code>autolow</code>，刚开始着重于速度，但当需要时随时提升美观。</li>
<li><code>autohigh</code>，同时着重播放速度和美观，但需要时则牺牲美观来保证播放速度。</li>
<li><code>medium</code>，应用一些反锯齿而不平滑位图。它质量高于<code>low</code>设置而低于<code>high</code>设置。</li>
<li><code>high</code>，美观优于播放速度，而且一直应用反锯齿。如果影片不包含动画，位图会被平滑化；而如果影片包含动画，位图将不变平滑。</li>
<li><code>best</code>，提供最好的显示质量而不考虑播放速度。所有输出都应用反锯齿及所有位图都被平滑化。</li>
</ul>
</li>
<li><code>bgcolor</code>，设置文件背景颜色。使用这个属性覆盖文件中设定的背景颜色。</li>
<li><code>play</code>，设置文件加载完成后是否自动播放，默认为<code>true</code>。</li>
<li><code>loop</code>，设置文件播放完后是否循环，默认为<code>true</code>。</li>
<li><code>scale</code><ul>
<li><code>showall</code>，默认设置，文件在指定区域显示，但保持原始比例，文件两侧会出现边框。</li>
<li><code>noborder</code>，收缩文件以适应指定区域，但保持原始比例，文件不失真，但部分文件可能被裁切。</li>
<li><code>exactfit</code>，使文件自适应指定区域，文件可能失真变形或改变显示比例。</li>
</ul>
</li>
<li><code>menu</code><ul>
<li><code>true</code>，显示全部的菜单，允许用户放大，缩小等控制文件播放的操作。</li>
<li><code>false</code>，只显示包含设置选项和关于文件的菜单。</li>
</ul>
</li>
<li><code>allowScriptAccess</code><ul>
<li><code>always</code>，默认设置，代表任何文件都被允许调用脚本。</li>
<li><code>sameDomain</code>，设置文件的脚本调用权限范围为同一域名。    </li>
<li><code>never</code>，代表不允许调用脚本。</li>
</ul>
</li>
<li><code>devicefont</code>，是否设置为设备字体样式。</li>
<li><code>align</code>，默认为居中，当浏览器窗口小于文件时，边缘会被裁切。可设置为<code>left</code>，<code>right</code>，<code>top</code>，<code>bottom</code>，设置后如有需要，另外三边将被裁切。</li>
<li><code>standby</code>，设置文件正在加载时显示的文本。</li>
</ul>
<h3 id="遇到的问题">遇到的问题</h3><ol>
<li>在<code>embed</code>中设置<code>play=“false”</code>即文件加载后不自动播放时如果出问题，可再设置<code>flashvars=&quot;autoplay=false&amp;play=false&quot;</code>。</li>
<li>视频全屏按钮点击无效时，可设置<code>allowFullScreen=&quot;true&quot;</code>。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近用到.swf的文件，一时不知如何调用，搜索后知道可以使用<code>object</code>标签或者<code>embed</code>标签来嵌入，参照着其他代码改完后，马马虎虎可以使用了。今天特意整理了其中的一些说明。原网页使用的代码如下：</p>]]>
    
    </summary>
    
      <category term="HTML" scheme="http://zhaoshibo.net/tags/HTML/"/>
    
      <category term="Tips" scheme="http://zhaoshibo.net/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[点击QQ号码弹出聊天窗口]]></title>
    <link href="http://zhaoshibo.net/blog/2015/09/07/%E7%82%B9%E5%87%BBQQ%E5%8F%B7%E7%A0%81%E5%BC%B9%E5%87%BA%E8%81%8A%E5%A4%A9%E7%AA%97%E5%8F%A3/"/>
    <id>http://zhaoshibo.net/blog/2015/09/07/点击QQ号码弹出聊天窗口/</id>
    <published>2015-09-07T06:10:23.000Z</published>
    <updated>2016-10-31T12:18:49.000Z</updated>
    <content type="html"><![CDATA[<p>2种旧方法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"tencent://message/?exe=qq&amp;menu=yes&amp;uin=QQ号码"</span> <span class="attribute">rel</span>=<span class="value">"nofollow"</span>&gt;</span><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://wpa.qq.com/msgrd?v=3&amp;uin=QQ号码&amp;site=qq&amp;menu=yes"</span> <span class="attribute">target</span>=<span class="value">"_blank"</span> <span class="attribute">rel</span>=<span class="value">"nofollow"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">img</span> <span class="attribute">border</span>=<span class="value">"0"</span> <span class="attribute">src</span>=<span class="value">"http://wpa.qq.com/pa?p=2:QQ号码:41"</span> <span class="attribute">alt</span>=<span class="value">"点击这里给我发消息"</span> <span class="attribute">title</span>=<span class="value">"点击这里给我发消息"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>1种新的方法，不会提示因“对方按钮版本过低”而无法打开。其中的<code>aty</code>和<code>a</code>值的参数影响着营销QQ中的分组及对应人员，具体设置时候还是需要重新生成。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://crm2.qq.com/page/portalpage/wpa.php?uin=QQ号码&amp;aty=0&amp;a=0&amp;curl=&amp;ty=1</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>2种旧方法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><]]>
    </summary>
    
      <category term="HTML" scheme="http://zhaoshibo.net/tags/HTML/"/>
    
      <category term="Tips" scheme="http://zhaoshibo.net/tags/Tips/"/>
    
  </entry>
  
</feed>
